{"version":3,"file":"index.d.cts","names":["RunnableConfig","BaseCheckpointSaver","Checkpoint","CheckpointListOptions","CheckpointTuple","SerializerProtocol","PendingWrite","CheckpointMetadata","ChannelVersions","pg","PostgresSaverOptions","PostgresSaver","Pool","Partial","Promise","Omit","Uint8Array","Record","AsyncGenerator"],"sources":["../src/index.d.ts"],"sourcesContent":["import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport { BaseCheckpointSaver, type Checkpoint, type CheckpointListOptions, type CheckpointTuple, type SerializerProtocol, type PendingWrite, type CheckpointMetadata, type ChannelVersions } from \"@langchain/langgraph-checkpoint\";\nimport pg from \"pg\";\n/** @inline */\ninterface PostgresSaverOptions {\n    schema: string;\n}\n/**\n * LangGraph checkpointer that uses a Postgres instance as the backing store.\n * Uses the [node-postgres](https://node-postgres.com/) package internally\n * to connect to a Postgres instance.\n *\n * @example\n * ```\n * import { ChatOpenAI } from \"@langchain/openai\";\n * import { PostgresSaver } from \"@langchain/langgraph-checkpoint-postgres\";\n * import { createReactAgent } from \"@langchain/langgraph/prebuilt\";\n *\n * const checkpointer = PostgresSaver.fromConnString(\n *   \"postgresql://user:password@localhost:5432/db\",\n *   // optional configuration object\n *   {\n *     schema: \"custom_schema\" // defaults to \"public\"\n *   }\n * );\n *\n * // NOTE: you need to call .setup() the first time you're using your checkpointer\n * await checkpointer.setup();\n *\n * const graph = createReactAgent({\n *   tools: [getWeather],\n *   llm: new ChatOpenAI({\n *     model: \"gpt-4o-mini\",\n *   }),\n *   checkpointSaver: checkpointer,\n * });\n * const config = { configurable: { thread_id: \"1\" } };\n *\n * await graph.invoke({\n *   messages: [{\n *     role: \"user\",\n *     content: \"what's the weather in sf\"\n *   }],\n * }, config);\n * ```\n */\nexport declare class PostgresSaver extends BaseCheckpointSaver {\n    private readonly pool;\n    private readonly options;\n    private readonly SQL_STATEMENTS;\n    protected isSetup: boolean;\n    constructor(pool: pg.Pool, serde?: SerializerProtocol, options?: Partial<PostgresSaverOptions>);\n    /**\n     * Creates a new instance of PostgresSaver from a connection string.\n     *\n     * @param {string} connString - The connection string to connect to the Postgres database.\n     * @param {PostgresSaverOptions} [options] - Optional configuration object.\n     * @returns {PostgresSaver} A new instance of PostgresSaver.\n     *\n     * @example\n     * const connString = \"postgresql://user:password@localhost:5432/db\";\n     * const checkpointer = PostgresSaver.fromConnString(connString, {\n     *  schema: \"custom_schema\" // defaults to \"public\"\n     * });\n     * await checkpointer.setup();\n     */\n    static fromConnString(connString: string, options?: Partial<PostgresSaverOptions>): PostgresSaver;\n    /**\n     * Set up the checkpoint database asynchronously.\n     *\n     * This method creates the necessary tables in the Postgres database if they don't\n     * already exist and runs database migrations. It MUST be called directly by the user\n     * the first time checkpointer is used.\n     */\n    setup(): Promise<void>;\n    protected _loadCheckpoint(checkpoint: Omit<Checkpoint, \"pending_sends\" | \"channel_values\">, channelValues: [Uint8Array, Uint8Array, Uint8Array][]): Promise<Checkpoint>;\n    protected _loadBlobs(blobValues: [Uint8Array, Uint8Array, Uint8Array][]): Promise<Record<string, unknown>>;\n    protected _loadMetadata(metadata: Record<string, unknown>): Promise<any>;\n    protected _loadWrites(writes: [Uint8Array, Uint8Array, Uint8Array, Uint8Array][]): Promise<[string, string, unknown][]>;\n    protected _dumpBlobs(threadId: string, checkpointNs: string, values: Record<string, unknown>, versions: ChannelVersions): Promise<[\n        string,\n        string,\n        string,\n        string,\n        string,\n        Uint8Array | undefined\n    ][]>;\n    protected _dumpCheckpoint(checkpoint: Checkpoint): Record<string, unknown>;\n    protected _dumpMetadata(metadata: CheckpointMetadata): Promise<any>;\n    protected _dumpWrites(threadId: string, checkpointNs: string, checkpointId: string, taskId: string, writes: [string, unknown][]): Promise<[\n        string,\n        string,\n        string,\n        string,\n        number,\n        string,\n        string,\n        Uint8Array\n    ][]>;\n    /**\n     * Return WHERE clause predicates for a given list() config, filter, cursor.\n     *\n     * This method returns a tuple of a string and a tuple of values. The string\n     * is the parameterized WHERE clause predicate (including the WHERE keyword):\n     * \"WHERE column1 = $1 AND column2 IS $2\". The list of values contains the\n     * values for each of the corresponding parameters.\n     */\n    protected _searchWhere(config?: RunnableConfig, filter?: Record<string, unknown>, before?: RunnableConfig): [string, unknown[]];\n    /**\n     * Get a checkpoint tuple from the database.\n     * This method retrieves a checkpoint tuple from the Postgres database\n     * based on the provided config. If the config's configurable field contains\n     * a \"checkpoint_id\" key, the checkpoint with the matching thread_id and\n     * namespace is retrieved. Otherwise, the latest checkpoint for the given\n     * thread_id is retrieved.\n     * @param config The config to use for retrieving the checkpoint.\n     * @returns The retrieved checkpoint tuple, or undefined.\n     */\n    getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined>;\n    /**\n     * List checkpoints from the database.\n     *\n     * This method retrieves a list of checkpoint tuples from the Postgres database based\n     * on the provided config. The checkpoints are ordered by checkpoint ID in descending order (newest first).\n     */\n    list(config: RunnableConfig, options?: CheckpointListOptions): AsyncGenerator<CheckpointTuple>;\n    /** @internal */\n    _migratePendingSends(pendingSends: [Uint8Array, Uint8Array][], mutableRow: {\n        channel_values: [Uint8Array, Uint8Array, Uint8Array][];\n        checkpoint: Omit<Checkpoint, \"pending_sends\" | \"channel_values\">;\n    }): Promise<void>;\n    /**\n     * Save a checkpoint to the database.\n     *\n     * This method saves a checkpoint to the Postgres database. The checkpoint is associated\n     * with the provided config and its parent config (if any).\n     * @param config\n     * @param checkpoint\n     * @param metadata\n     * @returns\n     */\n    put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata, newVersions: ChannelVersions): Promise<RunnableConfig>;\n    /**\n     * Store intermediate writes linked to a checkpoint.\n     *\n     * This method saves intermediate writes associated with a checkpoint to the Postgres database.\n     * @param config Configuration of the related checkpoint.\n     * @param writes List of writes to store.\n     * @param taskId Identifier for the task creating the writes.\n     */\n    putWrites(config: RunnableConfig, writes: PendingWrite[], taskId: string): Promise<void>;\n    end(): Promise<void>;\n    deleteThread(threadId: string): Promise<void>;\n}\nexport {};\n"],"mappings":";;;;;;UAIUU,oBAAAA;EAAAA,MAAAA,EAAAA,MAAAA;AA0CV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6D6DO,cA7DxCN,aAAAA,SAAsBV,mBAAAA,CA6DkBgB;mBAAkCjB,IAAAA;mBAW1EA,OAAAA;mBAAyBI,cAAAA;YAARU,OAAAA,EAAAA,OAAAA;aAOrBd,CAAAA,IAAAA,EA1EKS,EAAAA,CAAGG,IA0ERZ,EAAAA,KAAAA,CAAAA,EA1EsBK,kBA0EtBL,EAAAA,OAAAA,CAAAA,EA1EoDa,OA0EpDb,CA1E4DU,oBA0E5DV,CAAAA;;;;;;;;;;;;;;;SAgBkFQ,cAAAA,CAAAA,UAAAA,EAAAA,MAAAA,EAAAA,OAAAA,CAAAA,EA3E3CK,OA2E2CL,CA3EnCE,oBA2EmCF,CAAAA,CAAAA,EA3EXG,aA2EWH;;;;;;;;OA/FxDP,CAAAA,CAAAA,EA4B9Ba,OA5B8Bb,CAAAA,IAAAA,CAAAA;wCA6BDc,KAAKb,iEAAiEc,YAAYA,YAAYA,gBAAgBF,QAAQZ;oCAC1Hc,YAAYA,YAAYA,gBAAgBF,QAAQG;oCAChDA,0BAA0BH;iCAC7BE,YAAYA,YAAYA,YAAYA,gBAAgBF;uEACdG,mCAAmCT,kBAAkBM,iDAMtHE;wCAEkCd,aAAae;oCACjBV,qBAAqBO;oIAC2EA,iEAQ9HE;;;;;;;;;kCAU4BhB,yBAAyBiB,kCAAkCjB;;;;;;;;;;;mBAW1EA,iBAAiBc,QAAQV;;;;;;;eAO7BJ,0BAA0BG,wBAAwBe,eAAed;;sCAE1CY,YAAYA;qBAC3BA,YAAYA,YAAYA;gBAC7BD,KAAKb;MACjBY;;;;;;;;;;;cAWQd,4BAA4BE,sBAAsBK,iCAAiCC,kBAAkBM,QAAQd;;;;;;;;;oBASvGA,wBAAwBM,iCAAiCQ;SACpEA;kCACyBA"}