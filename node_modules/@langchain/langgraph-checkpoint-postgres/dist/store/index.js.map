{"version":3,"file":"index.js","names":["operation: PutOperation & { options?: { ttl?: number } }","operation: PutOperation","matchConditions: MatchCondition[]","operation: ListNamespacesOperation","migrationConfig: StoreMigrationConfig","error: unknown","results: unknown[]","params: unknown[]","conditions: string[]"],"sources":["../../src/store/index.ts"],"sourcesContent":["import pg from \"pg\";\nimport {\n  BaseStore,\n  type Operation,\n  type OperationResults,\n  type ListNamespacesOperation,\n  type PutOperation,\n  type Item,\n  type MatchCondition,\n} from \"@langchain/langgraph-checkpoint\";\n\n// Import types\nimport type {\n  PostgresStoreConfig,\n  SearchOptions,\n  SearchItem,\n  FilterOperators,\n} from \"./modules/types.js\";\n\n// Import modules\nimport { DatabaseCore } from \"./modules/database-core.js\";\nimport { VectorOperations } from \"./modules/vector-operations.js\";\nimport { CrudOperations } from \"./modules/crud-operations.js\";\nimport { SearchOperations } from \"./modules/search-operations.js\";\nimport { TTLManager } from \"./modules/ttl-manager.js\";\nimport {\n  getStoreMigrations,\n  StoreMigrationConfig,\n} from \"./store-migrations.js\";\nimport { getStoreTablesWithSchema } from \"./sql.js\";\n\nexport type * from \"./modules/types.js\";\n\nconst { Pool } = pg;\n\n/**\n * PostgreSQL implementation of the BaseStore interface.\n * This is now a lightweight orchestrator that delegates to specialized modules.\n */\nexport class PostgresStore extends BaseStore {\n  private core: DatabaseCore;\n\n  private vectorOps: VectorOperations;\n\n  private crudOps: CrudOperations;\n\n  private searchOps: SearchOperations;\n\n  private ttlManager: TTLManager;\n\n  private isSetup: boolean = false;\n\n  private isClosed: boolean = false;\n\n  private ensureTables: boolean;\n\n  constructor(config: PostgresStoreConfig) {\n    super();\n\n    // Create connection pool\n    const pool =\n      typeof config.connectionOptions === \"string\"\n        ? new Pool({ connectionString: config.connectionOptions })\n        : new Pool(config.connectionOptions);\n\n    // Initialize core and modules\n    this.core = new DatabaseCore(\n      pool,\n      config.schema || \"public\",\n      config.ttl,\n      config.index,\n      config.textSearchLanguage\n    );\n\n    this.vectorOps = new VectorOperations(this.core);\n    this.crudOps = new CrudOperations(this.core, this.vectorOps);\n    this.searchOps = new SearchOperations(this.core, this.vectorOps);\n    this.ttlManager = new TTLManager(this.core);\n\n    this.ensureTables = config.ensureTables ?? true;\n  }\n\n  /**\n   * Put an item with optional indexing configuration and TTL.\n   */\n  async put(\n    namespace: string[],\n    key: string,\n    value: Record<string, unknown>,\n    index?: false | string[],\n    options?: { ttl?: number }\n  ): Promise<void> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    return this.core.withClient(async (client) => {\n      const operation: PutOperation & { options?: { ttl?: number } } = {\n        namespace,\n        key,\n        value,\n        index,\n        options,\n      };\n\n      await this.crudOps.executePut(client, operation);\n    });\n  }\n\n  /**\n   * Get an item by namespace and key.\n   */\n  async get(namespace: string[], key: string): Promise<Item | null> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    return this.core.withClient(async (client) => {\n      return this.crudOps.executeGet(client, { namespace, key });\n    });\n  }\n\n  /**\n   * Delete an item by namespace and key.\n   */\n  async delete(namespace: string[], key: string): Promise<void> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    return this.core.withClient(async (client) => {\n      const operation: PutOperation = { namespace, key, value: null };\n      await this.crudOps.executePut(client, operation);\n    });\n  }\n\n  /**\n   * List namespaces with optional filtering.\n   */\n  async listNamespaces(\n    options: {\n      prefix?: string[];\n      suffix?: string[];\n      maxDepth?: number;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<string[][]> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;\n\n    // Convert options to match conditions format\n    const matchConditions: MatchCondition[] = [];\n\n    if (prefix) {\n      matchConditions.push({\n        matchType: \"prefix\",\n        path: prefix,\n      });\n    }\n\n    if (suffix) {\n      matchConditions.push({\n        matchType: \"suffix\",\n        path: suffix,\n      });\n    }\n\n    const operation: ListNamespacesOperation = {\n      matchConditions,\n      maxDepth,\n      limit,\n      offset,\n    };\n\n    return this.core.withClient(async (client) => {\n      return this.executeListNamespaces(client, operation);\n    });\n  }\n\n  /**\n   * Creates a PostgresStore instance from a connection string.\n   */\n  static fromConnString(\n    connectionString: string,\n    options?: Omit<PostgresStoreConfig, \"connectionOptions\">\n  ): PostgresStore {\n    return new PostgresStore({\n      connectionOptions: connectionString,\n      ...options,\n    });\n  }\n\n  /**\n   * Initialize the store by running migrations to create necessary tables and indexes.\n   */\n  async setup(): Promise<void> {\n    if (this.isSetup) return;\n\n    await this.runStoreMigrations();\n    this.isSetup = true;\n\n    // Start TTL sweeper if configured\n    if (this.core.ttlConfig?.sweepIntervalMinutes) {\n      this.ttlManager.start();\n    }\n  }\n\n  /**\n   * Run store migrations to set up the database schema\n   */\n  private async runStoreMigrations(): Promise<void> {\n    const client = await this.core.pool.connect();\n    const STORE_TABLES = getStoreTablesWithSchema(this.core.schema);\n\n    try {\n      await client.query(`CREATE SCHEMA IF NOT EXISTS ${this.core.schema}`);\n\n      let version = -1;\n\n      const migrationConfig: StoreMigrationConfig = {\n        schema: this.core.schema,\n        indexConfig: this.core.indexConfig\n          ? {\n              dims: this.core.indexConfig.dims,\n              indexType: this.core.indexConfig.indexType,\n              distanceMetric: this.core.indexConfig.distanceMetric,\n              createAllMetricIndexes:\n                this.core.indexConfig.createAllMetricIndexes,\n              hnsw: this.core.indexConfig.hnsw,\n              ivfflat: this.core.indexConfig.ivfflat,\n            }\n          : undefined,\n      };\n\n      const migrations = getStoreMigrations(migrationConfig);\n\n      // Check current migration version using the same pattern as checkpoints\n      try {\n        const result = await client.query(\n          `SELECT v FROM ${STORE_TABLES.store_migrations} ORDER BY v DESC LIMIT 1`\n        );\n        if (result.rows.length > 0) {\n          version = result.rows[0].v;\n        }\n      } catch (error: unknown) {\n        // Assume table doesn't exist if there's an error\n        if (\n          typeof error === \"object\" &&\n          error !== null &&\n          \"code\" in error &&\n          typeof error.code === \"string\" &&\n          error.code === \"42P01\" // Postgres error code for undefined_table\n        ) {\n          version = -1;\n        } else {\n          throw error;\n        }\n      }\n\n      // Run migrations starting from the next version\n      for (let v = version + 1; v < migrations.length; v += 1) {\n        await client.query(migrations[v]);\n        await client.query(\n          `INSERT INTO ${STORE_TABLES.store_migrations} (v) VALUES ($1)`,\n          [v]\n        );\n      }\n    } finally {\n      client.release();\n    }\n  }\n\n  /**\n   * Execute multiple operations in a single batch.\n   */\n  async batch<Op extends Operation[]>(\n    operations: Op\n  ): Promise<OperationResults<Op>> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    return this.core.withClient(async (client) => {\n      const results: unknown[] = [];\n\n      for (const operation of operations) {\n        if (\"namespacePrefix\" in operation) {\n          // SearchOperation\n          results.push(await this.searchOps.executeSearch(client, operation));\n        } else if (\"key\" in operation && !(\"value\" in operation)) {\n          // GetOperation\n          results.push(await this.crudOps.executeGet(client, operation));\n        } else if (\"value\" in operation) {\n          // PutOperation\n          results.push(await this.crudOps.executePut(client, operation));\n        } else if (\"matchConditions\" in operation) {\n          // ListNamespacesOperation\n          results.push(await this.executeListNamespaces(client, operation));\n        } else {\n          throw new Error(\n            `Unsupported operation type: ${JSON.stringify(operation)}`\n          );\n        }\n      }\n\n      return results as OperationResults<Op>;\n    });\n  }\n\n  private async executeListNamespaces(\n    client: pg.PoolClient,\n    operation: ListNamespacesOperation\n  ): Promise<string[][]> {\n    const { matchConditions, maxDepth, limit = 100, offset = 0 } = operation;\n\n    let sqlQuery = `\n      SELECT DISTINCT namespace_path\n      FROM ${this.core.schema}.store\n    `;\n\n    const params: unknown[] = [];\n    const conditions: string[] = [];\n    let paramIndex = 1;\n\n    // Add match conditions\n    if (matchConditions && matchConditions.length > 0) {\n      for (const condition of matchConditions) {\n        if (condition.matchType === \"prefix\") {\n          const prefix = condition.path.join(\":\");\n          conditions.push(`namespace_path LIKE $${paramIndex}`);\n          params.push(`${prefix}%`);\n          paramIndex += 1;\n        } else if (condition.matchType === \"suffix\") {\n          const suffix = condition.path.join(\":\");\n          conditions.push(`namespace_path LIKE $${paramIndex}`);\n          params.push(`%${suffix}`);\n          paramIndex += 1;\n        }\n      }\n    }\n\n    if (conditions.length > 0) {\n      sqlQuery += ` WHERE ${conditions.join(\" AND \")}`;\n    }\n\n    sqlQuery += ` ORDER BY namespace_path LIMIT $${paramIndex} OFFSET $${\n      paramIndex + 1\n    }`;\n    params.push(limit, offset);\n\n    const result = await client.query(sqlQuery, params);\n\n    let namespaces = result.rows.map((row) => row.namespace_path.split(\":\"));\n\n    // Apply maxDepth filter if specified\n    if (maxDepth !== undefined) {\n      namespaces = namespaces.filter((ns) => ns.length <= maxDepth);\n    }\n\n    return namespaces;\n  }\n\n  /**\n   * Start the store. Calls setup() if ensureTables is true.\n   */\n  async start(): Promise<void> {\n    if (this.ensureTables && !this.isSetup) {\n      await this.setup();\n    }\n  }\n\n  /**\n   * Stop the store and close all database connections.\n   */\n  async stop(): Promise<void> {\n    if (this.isClosed) return;\n\n    this.ttlManager.stop();\n    await this.core.pool.end();\n    this.isClosed = true;\n  }\n\n  /**\n   * Manually sweep expired items from the store.\n   */\n  async sweepExpiredItems(): Promise<number> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n    return this.ttlManager.sweepExpiredItems();\n  }\n\n  /**\n   * Enhanced search with advanced filtering and similarity scoring.\n   * @private Internal method used by search.\n   */\n  private async textSearch(\n    namespacePrefix: string[],\n    options: SearchOptions = {}\n  ): Promise<SearchItem[]> {\n    return this.searchOps.textSearch(namespacePrefix, options);\n  }\n\n  /**\n   * Get statistics about the store.\n   */\n  async getStats(): Promise<{\n    totalItems: number;\n    expiredItems: number;\n    namespaceCount: number;\n    oldestItem: Date | null;\n    newestItem: Date | null;\n  }> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    return this.core.withClient(async (client) => {\n      const result = await client.query(`\n        SELECT \n          COUNT(*) as total_items,\n          COUNT(CASE WHEN expires_at IS NOT NULL AND expires_at <= CURRENT_TIMESTAMP THEN 1 END) as expired_items,\n          COUNT(DISTINCT namespace_path) as namespace_count,\n          MIN(created_at) as oldest_item,\n          MAX(created_at) as newest_item\n        FROM ${this.core.schema}.store\n      `);\n\n      const row = result.rows[0];\n      return {\n        totalItems: parseInt(row.total_items, 10),\n        expiredItems: parseInt(row.expired_items, 10),\n        namespaceCount: parseInt(row.namespace_count, 10),\n        oldestItem: row.oldest_item,\n        newestItem: row.newest_item,\n      };\n    });\n  }\n\n  /**\n   * Performs vector similarity search using embeddings.\n   *\n   * @param namespacePrefix - The namespace prefix to search within\n   * @param query - The text query to embed and search for similar items\n   * @param options - Search options including filter, similarity threshold, and distance metric\n   * @returns Promise resolving to an array of search results with similarity scores\n   */\n  protected async vectorSearch(\n    namespacePrefix: string[],\n    query: string,\n    options: {\n      filter?: Record<string, unknown>;\n      limit?: number;\n      offset?: number;\n      similarityThreshold?: number;\n      distanceMetric?: \"cosine\" | \"l2\" | \"inner_product\";\n    } = {}\n  ): Promise<SearchItem[]> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    if (!this.core.indexConfig) {\n      throw new Error(\n        \"Vector search not configured. Please provide an IndexConfig when creating the store.\"\n      );\n    }\n\n    return this.searchOps.vectorSearch(namespacePrefix, query, options);\n  }\n\n  /**\n   * Performs hybrid search combining vector similarity and text search.\n   *\n   * @param namespacePrefix - The namespace prefix to search within\n   * @param query - The text query to search for\n   * @param options - Search options including filter, vector weight, and similarity threshold\n   * @returns Promise resolving to an array of search results with combined similarity scores\n   */\n  protected async hybridSearch(\n    namespacePrefix: string[],\n    query: string,\n    options: {\n      filter?: Record<string, unknown>;\n      limit?: number;\n      offset?: number;\n      vectorWeight?: number;\n      similarityThreshold?: number;\n    } = {}\n  ): Promise<SearchItem[]> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    if (!this.core.indexConfig) {\n      throw new Error(\n        \"Vector search not configured. Please provide an IndexConfig when creating the store.\"\n      );\n    }\n\n    return this.searchOps.hybridSearch(namespacePrefix, query, options);\n  }\n\n  /**\n   * Search for items in the store with support for text search, vector search, and filtering.\n   *\n   * @param namespacePrefix - The namespace prefix to search within\n   * @param options - Search options including search mode, filters, query text, and pagination\n   * @returns Promise resolving to an array of search results with optional similarity scores\n   *\n   * @example\n   * ```typescript\n   * // Basic text search\n   * const results = await store.search([\"documents\"], {\n   *   query: \"machine learning\",\n   *   mode: \"text\"\n   * });\n   *\n   * // Vector search\n   * const results = await store.search([\"documents\"], {\n   *   query: \"machine learning\",\n   *   mode: \"vector\",\n   *   similarityThreshold: 0.7\n   * });\n   *\n   * // Hybrid search (combining vector and text)\n   * const results = await store.search([\"documents\"], {\n   *   query: \"machine learning\",\n   *   mode: \"hybrid\",\n   *   vectorWeight: 0.7\n   * });\n   *\n   * // Filtered search\n   * const results = await store.search([\"products\"], {\n   *   filter: { category: \"electronics\", price: { $lt: 100 } }\n   * });\n   * ```\n   */\n  async search(\n    namespacePrefix: string[],\n    options: {\n      /**\n       * Filter conditions with support for advanced operators.\n       */\n      filter?: Record<\n        string,\n        string | number | boolean | null | FilterOperators\n      >;\n\n      /**\n       * Natural language search query.\n       */\n      query?: string;\n\n      /**\n       * Maximum number of results to return.\n       * @default 10\n       */\n      limit?: number;\n\n      /**\n       * Number of results to skip for pagination.\n       * @default 0\n       */\n      offset?: number;\n\n      /**\n       * Whether to refresh TTL for returned items.\n       */\n      refreshTtl?: boolean;\n\n      /**\n       * Search mode.\n       * @default \"auto\"\n       */\n      mode?: \"text\" | \"vector\" | \"hybrid\" | \"auto\";\n\n      /**\n       * Similarity threshold for vector search.\n       */\n      similarityThreshold?: number;\n\n      /**\n       * Distance metric for vector search.\n       * @default \"cosine\"\n       */\n      distanceMetric?: \"cosine\" | \"l2\" | \"inner_product\";\n\n      /**\n       * Weight for vector search in hybrid mode.\n       * @default 0.7\n       */\n      vectorWeight?: number;\n    } = {}\n  ): Promise<SearchItem[]> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const { mode = \"auto\", query, ...restOptions } = options;\n\n    // No query provided - just do metadata filtering\n    if (!query) {\n      return this.textSearch(namespacePrefix, restOptions);\n    }\n\n    const hasVectorSearch = Boolean(this.core.indexConfig);\n\n    // Determine search mode based on configuration and options\n    let effectiveMode = mode;\n    if (mode === \"auto\") {\n      effectiveMode = hasVectorSearch ? \"vector\" : \"text\";\n    }\n\n    // Execute appropriate search based on mode\n    switch (effectiveMode) {\n      case \"vector\":\n        if (!hasVectorSearch) {\n          throw new Error(\n            \"Vector search requested but not configured. Please provide an IndexConfig when creating the store.\"\n          );\n        }\n        return this.vectorSearch(namespacePrefix, query, {\n          ...restOptions,\n          similarityThreshold: options.similarityThreshold,\n          distanceMetric: options.distanceMetric,\n        });\n\n      case \"hybrid\":\n        if (!hasVectorSearch) {\n          throw new Error(\n            \"Hybrid search requested but vector search not configured. Please provide an IndexConfig when creating the store.\"\n          );\n        }\n        return this.hybridSearch(namespacePrefix, query, {\n          ...restOptions,\n          vectorWeight: options.vectorWeight,\n          similarityThreshold: options.similarityThreshold,\n        });\n\n      case \"text\":\n        return this.textSearch(namespacePrefix, { query, ...restOptions });\n\n      default:\n        throw new Error(`Unknown search mode: ${mode}`);\n    }\n  }\n}\n"],"mappings":"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"}