//#region src/store/modules/vector-operations.ts
/**
* Handles vector processing, embeddings, and text extraction.
*/
var VectorOperations = class {
	constructor(core) {
		this.core = core;
	}
	async indexItemVectors(client, namespacePath, key, value, index) {
		if (!this.core.indexConfig || index === false) return;
		await client.query(`
      DELETE FROM ${this.core.schema}.store_vectors 
      WHERE namespace_path = $1 AND key = $2
    `, [namespacePath, key]);
		const fields = index || this.core.indexConfig.fields || ["$"];
		const textsToEmbed = [];
		for (const fieldPath of fields) {
			const extractedTexts = this.extractTextAtPath(value, fieldPath);
			extractedTexts.forEach((text, i) => {
				const trimmedText = text?.trim();
				if (trimmedText) {
					const actualFieldPath = extractedTexts.length > 1 ? `${fieldPath}[${i}]` : fieldPath;
					textsToEmbed.push({
						fieldPath: actualFieldPath,
						text: trimmedText
					});
				}
			});
		}
		if (textsToEmbed.length === 0) return;
		const texts = textsToEmbed.map((item) => item.text);
		const embeddings = await this.generateEmbeddings(texts);
		for (let i = 0; i < textsToEmbed.length; i += 1) {
			const { fieldPath, text } = textsToEmbed[i];
			const embedding = embeddings[i];
			if (embedding?.length === this.core.indexConfig.dims) await client.query(`
          INSERT INTO ${this.core.schema}.store_vectors 
          (namespace_path, key, field_path, text_content, embedding)
          VALUES ($1, $2, $3, $4, $5)
        `, [
				namespacePath,
				key,
				fieldPath,
				text,
				`[${embedding.join(",")}]`
			]);
		}
	}
	async generateEmbeddings(texts) {
		if (!this.core.indexConfig) throw new Error("Vector search not configured");
		const { embed } = this.core.indexConfig;
		if (typeof embed === "function") return await embed(texts);
		if (embed && typeof embed === "object" && "embedDocuments" in embed) return await embed.embedDocuments(texts);
		throw new Error("Invalid embedding configuration");
	}
	async generateQueryEmbedding(text) {
		if (!this.core.indexConfig) throw new Error("Vector search not configured");
		const { embed } = this.core.indexConfig;
		if (typeof embed === "function") {
			const embeddings = await embed([text]);
			return embeddings[0] || [];
		}
		if (embed && typeof embed === "object" && "embedQuery" in embed) return await embed.embedQuery(text);
		if (embed && typeof embed === "object" && "embedDocuments" in embed) {
			const embeddings = await embed.embedDocuments([text]);
			return embeddings[0] || [];
		}
		throw new Error("Invalid embedding configuration");
	}
	extractTextAtPath(obj, path) {
		if (path === "$") return [JSON.stringify(obj)];
		const parts = path.split(".");
		let current = obj;
		const results = [];
		try {
			for (let i = 0; i < parts.length; i += 1) {
				const part = parts[i];
				if (part.includes("[")) {
					const [field, arrayPart] = part.split("[");
					const arrayIndex = arrayPart.replace("]", "");
					if (field && typeof current === "object" && current !== null) current = current[field];
					if (arrayIndex === "*") {
						if (Array.isArray(current)) {
							const remainingPath = parts.slice(i + 1).join(".");
							if (remainingPath) {
								for (const item of current) if (item != null) results.push(...this.extractTextAtPath(item, remainingPath));
							} else for (const item of current) if (typeof item === "string") results.push(item);
							else if (typeof item === "object" && item !== null) results.push(JSON.stringify(item));
							else if (item != null) results.push(String(item));
						}
						return results;
					} else if (arrayIndex === "-1") {
						if (Array.isArray(current) && current.length > 0) current = current[current.length - 1];
					} else {
						const index = parseInt(arrayIndex, 10);
						if (Array.isArray(current) && index >= 0 && index < current.length) current = current[index];
					}
				} else if (typeof current === "object" && current !== null) current = current[part];
				if (current == null) return [];
			}
			if (typeof current === "string") results.push(current);
			else if (typeof current === "object" && current !== null) results.push(JSON.stringify(current));
			else results.push(String(current));
		} catch (error) {
			return [];
		}
		return results;
	}
};

//#endregion
export { VectorOperations };
//# sourceMappingURL=vector-operations.js.map