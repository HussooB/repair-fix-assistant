{"version":3,"file":"crud-operations.cjs","names":["core: DatabaseCore","vectorOps: VectorOperations"],"sources":["../../../src/store/modules/crud-operations.ts"],"sourcesContent":["import pg from \"pg\";\nimport {\n  type Item,\n  type GetOperation,\n  type PutOperation,\n} from \"@langchain/langgraph-checkpoint\";\nimport { DatabaseCore } from \"./database-core.js\";\nimport { VectorOperations } from \"./vector-operations.js\";\nimport { PutOptions } from \"./types.js\";\nimport { validateNamespace } from \"./utils.js\";\n\n/**\n * Handles basic CRUD operations: get, put, delete.\n */\nexport class CrudOperations {\n  constructor(\n    private core: DatabaseCore,\n    private vectorOps: VectorOperations\n  ) {}\n\n  async executeGet(\n    client: pg.PoolClient,\n    operation: GetOperation\n  ): Promise<Item | null> {\n    validateNamespace(operation.namespace);\n\n    const namespacePath = operation.namespace.join(\":\");\n\n    const result = await client.query(\n      `\n      SELECT namespace_path, key, value, created_at, updated_at\n      FROM ${this.core.schema}.store\n      WHERE namespace_path = $1 AND key = $2\n        AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)\n    `,\n      [namespacePath, operation.key]\n    );\n\n    if (result.rows.length === 0) return null;\n\n    const row = result.rows[0];\n\n    // Refresh TTL if configured\n    if (this.core.ttlConfig?.refreshOnRead) {\n      await this.core.refreshTtl(client, namespacePath, operation.key);\n    }\n\n    return {\n      namespace: row.namespace_path.split(\":\"),\n      key: row.key,\n      value: row.value,\n      createdAt: row.created_at,\n      updatedAt: row.updated_at,\n    };\n  }\n\n  async executePut(\n    client: pg.PoolClient,\n    operation: PutOperation & { options?: PutOptions }\n  ): Promise<void> {\n    validateNamespace(operation.namespace);\n    const { namespace, key, value, options, index } = operation;\n\n    const namespacePath = namespace.join(\":\");\n\n    if (value === null) {\n      // Delete operation\n      await client.query(\n        `\n        DELETE FROM ${this.core.schema}.store\n        WHERE namespace_path = $1 AND key = $2\n      `,\n        [namespacePath, key]\n      );\n    } else {\n      const expiresAt = this.core.calculateExpiresAt(options?.ttl);\n\n      await client.query(\n        `\n        INSERT INTO ${this.core.schema}.store (namespace_path, key, value, expires_at)\n        VALUES ($1, $2, $3, $4)\n        ON CONFLICT (namespace_path, key)\n        DO UPDATE SET \n          value = $3,\n          expires_at = $4,\n          updated_at = CURRENT_TIMESTAMP\n      `,\n        [namespacePath, key, JSON.stringify(value), expiresAt]\n      );\n\n      // Handle vector indexing if configured\n      if (this.core.indexConfig && index !== false) {\n        await this.vectorOps.indexItemVectors(\n          client,\n          namespacePath,\n          key,\n          value,\n          index // Pass the index parameter to control which fields get indexed\n        );\n      }\n    }\n  }\n}\n"],"mappings":";;;;;;AAcA,IAAa,iBAAb,MAA4B;CAC1B,YACE,AAAQA,MACR,AAAQC,WACR;EAFQ;EACA;;CAGV,MAAM,WACJ,QACA,WACsB;AACtB,kCAAkB,UAAU;EAE5B,MAAM,gBAAgB,UAAU,UAAU,KAAK;EAE/C,MAAM,SAAS,MAAM,OAAO,MAC1B;;aAEO,KAAK,KAAK,OAAO;;;OAIxB,CAAC,eAAe,UAAU;AAG5B,MAAI,OAAO,KAAK,WAAW,EAAG,QAAO;EAErC,MAAM,MAAM,OAAO,KAAK;AAGxB,MAAI,KAAK,KAAK,WAAW,cACvB,OAAM,KAAK,KAAK,WAAW,QAAQ,eAAe,UAAU;AAG9D,SAAO;GACL,WAAW,IAAI,eAAe,MAAM;GACpC,KAAK,IAAI;GACT,OAAO,IAAI;GACX,WAAW,IAAI;GACf,WAAW,IAAI;;;CAInB,MAAM,WACJ,QACA,WACe;AACf,kCAAkB,UAAU;EAC5B,MAAM,EAAE,WAAW,KAAK,OAAO,SAAS,UAAU;EAElD,MAAM,gBAAgB,UAAU,KAAK;AAErC,MAAI,UAAU,KAEZ,OAAM,OAAO,MACX;sBACc,KAAK,KAAK,OAAO;;SAG/B,CAAC,eAAe;OAEb;GACL,MAAM,YAAY,KAAK,KAAK,mBAAmB,SAAS;AAExD,SAAM,OAAO,MACX;sBACc,KAAK,KAAK,OAAO;;;;;;;SAQ/B;IAAC;IAAe;IAAK,KAAK,UAAU;IAAQ;;AAI9C,OAAI,KAAK,KAAK,eAAe,UAAU,MACrC,OAAM,KAAK,UAAU,iBACnB,QACA,eACA,KACA,OACA"}