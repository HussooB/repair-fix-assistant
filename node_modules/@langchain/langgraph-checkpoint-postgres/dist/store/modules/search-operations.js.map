{"version":3,"file":"search-operations.js","names":["core: DatabaseCore","vectorOps: VectorOperations","params: unknown[]","items: SearchItem[]","distanceOp: string","scoreTransform: string"],"sources":["../../../src/store/modules/search-operations.ts"],"sourcesContent":["import pg from \"pg\";\nimport {\n  type Item,\n  type SearchOperation,\n} from \"@langchain/langgraph-checkpoint\";\nimport { DatabaseCore } from \"./database-core.js\";\nimport { VectorOperations } from \"./vector-operations.js\";\nimport { QueryBuilder } from \"./query-builder.js\";\nimport { SearchOptions, SearchItem } from \"./types.js\";\nimport { validateNamespace } from \"./utils.js\";\n\n/**\n * Handles all search operations: basic search, vector search, hybrid search.\n */\nexport class SearchOperations {\n  constructor(\n    private core: DatabaseCore,\n    private vectorOps: VectorOperations\n  ) {}\n\n  async executeSearch(\n    client: pg.PoolClient,\n    operation: SearchOperation\n  ): Promise<Item[]> {\n    validateNamespace(operation.namespacePrefix);\n\n    const namespacePath = operation.namespacePrefix.join(\":\");\n    const { filter, limit = 10, offset = 0, query } = operation;\n\n    // If vector search is configured and query is provided, use vector similarity search\n    if (query && this.core.indexConfig) {\n      return this.executeVectorSearch(client, operation);\n    }\n\n    // If query is provided but no vector search, use text search for better results\n    if (query && !this.core.indexConfig) {\n      const results = await this.textSearch(operation.namespacePrefix, {\n        query,\n        filter,\n        limit,\n        offset,\n      });\n\n      // Convert SearchItem[] to Item[] for consistent return type\n      return results.map((item) => ({\n        namespace: item.namespace,\n        key: item.key,\n        value: item.value,\n        createdAt: item.createdAt,\n        updatedAt: item.updatedAt,\n      }));\n    }\n\n    // Basic metadata search without query\n    let sqlQuery = `\n      SELECT namespace_path, key, value, created_at, updated_at\n      FROM ${this.core.schema}.store\n      WHERE namespace_path LIKE $1\n        AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)\n    `;\n\n    const params: unknown[] = [`${namespacePath}%`];\n    let paramIndex = 2;\n\n    // Add filter conditions using advanced filtering\n    if (filter && Object.keys(filter).length > 0) {\n      const { conditions, newParamIndex } = QueryBuilder.buildFilterConditions(\n        filter,\n        params,\n        paramIndex\n      );\n      if (conditions.length > 0) {\n        sqlQuery += ` AND (${conditions.join(\" AND \")})`;\n        paramIndex = newParamIndex;\n      }\n    }\n\n    sqlQuery += ` ORDER BY created_at DESC LIMIT $${paramIndex} OFFSET $${\n      paramIndex + 1\n    }`;\n    params.push(limit, offset);\n\n    const result = await client.query(sqlQuery, params);\n\n    return result.rows.map((row) => ({\n      namespace: row.namespace_path.split(\":\"),\n      key: row.key,\n      value: row.value,\n      createdAt: row.created_at,\n      updatedAt: row.updated_at,\n    }));\n  }\n\n  async executeVectorSearch(\n    client: pg.PoolClient,\n    operation: SearchOperation\n  ): Promise<Item[]> {\n    if (!this.core.indexConfig || !operation.query) return [];\n\n    validateNamespace(operation.namespacePrefix);\n\n    const namespacePath = operation.namespacePrefix.join(\":\");\n    const { filter, limit = 10, offset = 0, query } = operation;\n\n    // Generate query embedding\n    const queryEmbedding = await this.vectorOps.generateQueryEmbedding(query);\n\n    if (queryEmbedding.length !== this.core.indexConfig.dims) {\n      throw new Error(\n        `Query embedding dimension mismatch: expected ${this.core.indexConfig.dims}, got ${queryEmbedding.length}`\n      );\n    }\n\n    let sqlQuery = `\n      SELECT DISTINCT \n        s.namespace_path, \n        s.key, \n        s.value, \n        s.created_at, \n        s.updated_at,\n        MIN(v.embedding <=> $2) as similarity_score\n      FROM ${this.core.schema}.store s\n      JOIN ${this.core.schema}.store_vectors v ON s.namespace_path = v.namespace_path AND s.key = v.key\n      WHERE s.namespace_path LIKE $1\n        AND (s.expires_at IS NULL OR s.expires_at > CURRENT_TIMESTAMP)\n    `;\n\n    const params: unknown[] = [\n      `${namespacePath}%`,\n      `[${queryEmbedding.join(\",\")}]`,\n    ];\n    let paramIndex = 3;\n\n    // Add filter conditions\n    if (filter && Object.keys(filter).length > 0) {\n      const { conditions, newParamIndex } = QueryBuilder.buildFilterConditions(\n        filter,\n        params,\n        paramIndex\n      );\n      if (conditions.length > 0) {\n        // Adjust conditions to use 's.' prefix for store table columns\n        const adjustedConditions = conditions.map((condition: string) =>\n          condition.replace(/value ->/g, \"s.value ->\")\n        );\n        sqlQuery += ` AND (${adjustedConditions.join(\" AND \")})`;\n        paramIndex = newParamIndex;\n      }\n    }\n\n    sqlQuery += ` \n      GROUP BY s.namespace_path, s.key, s.value, s.created_at, s.updated_at\n      ORDER BY similarity_score ASC \n      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}\n    `;\n    params.push(limit, offset);\n\n    const result = await client.query(sqlQuery, params);\n\n    return result.rows.map((row) => ({\n      namespace: row.namespace_path.split(\":\"),\n      key: row.key,\n      value: row.value,\n      createdAt: row.created_at,\n      updatedAt: row.updated_at,\n      score: 1 - parseFloat(row.similarity_score), // Convert distance to similarity\n    }));\n  }\n\n  async textSearch(\n    namespacePrefix: string[],\n    options: SearchOptions = {}\n  ): Promise<SearchItem[]> {\n    return this.core.withClient(async (client) => {\n      validateNamespace(namespacePrefix);\n\n      const namespacePath = namespacePrefix.join(\":\");\n      const { filter, limit = 10, offset = 0, query, refreshTtl } = options;\n\n      let sqlQuery = `\n        SELECT \n          namespace_path, \n          key, \n          value, \n          created_at, \n          updated_at,\n          CASE \n            WHEN $2::text IS NOT NULL THEN \n              ts_rank(to_tsvector($3::regconfig, value::text), plainto_tsquery($3::regconfig, $2::text))\n            ELSE 0\n          END as score\n        FROM ${this.core.schema}.store\n        WHERE namespace_path LIKE $1\n          AND (expires_at IS NULL OR expires_at > CURRENT_TIMESTAMP)\n      `;\n\n      const params: unknown[] = [\n        `${namespacePath}%`,\n        query || null,\n        this.core.textSearchLanguage,\n      ];\n      let paramIndex = 4;\n\n      // Add filter conditions using advanced filtering\n      if (filter && Object.keys(filter).length > 0) {\n        const { conditions, newParamIndex } =\n          QueryBuilder.buildFilterConditions(filter, params, paramIndex);\n        if (conditions.length > 0) {\n          sqlQuery += ` AND (${conditions.join(\" AND \")})`;\n          paramIndex = newParamIndex;\n        }\n      }\n\n      // Add full-text search if query is provided\n      if (query) {\n        sqlQuery += ` AND (\n          to_tsvector($3::regconfig, value::text) @@ plainto_tsquery($3::regconfig, $2::text)\n          OR value::text ILIKE $${paramIndex}\n        )`;\n        params.push(`%${query}%`);\n        paramIndex += 1;\n      }\n\n      // Add ordering by score if query provided, otherwise by updated_at\n      if (query) {\n        sqlQuery += ` ORDER BY score DESC, updated_at DESC`;\n      } else {\n        sqlQuery += ` ORDER BY updated_at DESC`;\n      }\n\n      sqlQuery += ` LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;\n      params.push(limit, offset);\n\n      const result = await client.query(sqlQuery, params);\n\n      const items: SearchItem[] = result.rows.map((row) => ({\n        namespace: row.namespace_path.split(\":\"),\n        key: row.key,\n        value: row.value,\n        createdAt: row.created_at || new Date(),\n        updatedAt: row.updated_at || new Date(),\n        score: row.score || undefined,\n      }));\n\n      // Refresh TTL for returned items if requested\n      if (refreshTtl || this.core.ttlConfig?.refreshOnRead) {\n        for (const item of items) {\n          await this.core.refreshTtl(\n            client,\n            item.namespace.join(\":\"),\n            item.key\n          );\n        }\n      }\n\n      return items;\n    });\n  }\n\n  async vectorSearch(\n    namespacePrefix: string[],\n    query: string,\n    options: {\n      filter?: Record<string, unknown>;\n      limit?: number;\n      offset?: number;\n      similarityThreshold?: number;\n      distanceMetric?: \"cosine\" | \"l2\" | \"inner_product\";\n    } = {}\n  ): Promise<SearchItem[]> {\n    if (!this.core.indexConfig) {\n      throw new Error(\n        \"Vector search not configured. Please provide an IndexConfig when creating the store.\"\n      );\n    }\n\n    return this.core.withClient(async (client) => {\n      validateNamespace(namespacePrefix);\n\n      const namespacePath = namespacePrefix.join(\":\");\n      const {\n        filter,\n        limit = 10,\n        offset = 0,\n        similarityThreshold = 0.0,\n        distanceMetric = \"cosine\",\n      } = options;\n\n      // Generate query embedding\n      const queryEmbedding = await this.vectorOps.generateQueryEmbedding(query);\n\n      if (queryEmbedding.length !== this.core.indexConfig!.dims) {\n        throw new Error(\n          `Query embedding dimension mismatch: expected ${\n            this.core.indexConfig!.dims\n          }, got ${queryEmbedding.length}`\n        );\n      }\n\n      // Choose distance operator based on metric\n      let distanceOp: string;\n      let scoreTransform: string;\n      switch (distanceMetric) {\n        case \"l2\":\n          distanceOp = \"<->\";\n          scoreTransform = \"1 / (1 + MIN(v.embedding <-> $2))\"; // Convert L2 distance to similarity\n          break;\n        case \"inner_product\":\n          distanceOp = \"<#>\";\n          scoreTransform = \"MIN(v.embedding <#> $2)\"; // Inner product (higher is better)\n          break;\n        case \"cosine\":\n        default:\n          distanceOp = \"<=>\";\n          scoreTransform = \"1 - MIN(v.embedding <=> $2)\"; // Convert cosine distance to similarity\n          break;\n      }\n\n      let sqlQuery = `\n        SELECT DISTINCT \n          s.namespace_path, \n          s.key, \n          s.value, \n          s.created_at, \n          s.updated_at,\n          ${scoreTransform} as similarity_score\n        FROM ${this.core.schema}.store s\n        JOIN ${this.core.schema}.store_vectors v ON s.namespace_path = v.namespace_path AND s.key = v.key\n        WHERE s.namespace_path LIKE $1\n          AND (s.expires_at IS NULL OR s.expires_at > CURRENT_TIMESTAMP)\n      `;\n\n      const params: unknown[] = [\n        `${namespacePath}%`,\n        `[${queryEmbedding.join(\",\")}]`,\n      ];\n      let paramIndex = 3;\n\n      // Add similarity threshold\n      if (similarityThreshold > 0) {\n        if (distanceMetric === \"inner_product\") {\n          sqlQuery += ` AND v.embedding <#> $2 >= $${paramIndex}`;\n        } else {\n          sqlQuery += ` AND v.embedding ${distanceOp} $2 <= $${paramIndex}`;\n        }\n        params.push(\n          distanceMetric === \"cosine\"\n            ? 1 - similarityThreshold\n            : similarityThreshold\n        );\n        paramIndex += 1;\n      }\n\n      // Add filter conditions\n      if (filter && Object.keys(filter).length > 0) {\n        const { conditions, newParamIndex } =\n          QueryBuilder.buildFilterConditions(filter, params, paramIndex);\n        if (conditions.length > 0) {\n          const adjustedConditions = conditions.map((condition: string) =>\n            condition.replace(/value ->/g, \"s.value ->\")\n          );\n          sqlQuery += ` AND (${adjustedConditions.join(\" AND \")})`;\n          paramIndex = newParamIndex;\n        }\n      }\n\n      const orderDirection = \"DESC\"; // From most similar to least similar\n      sqlQuery += ` \n        GROUP BY s.namespace_path, s.key, s.value, s.created_at, s.updated_at\n        ORDER BY similarity_score ${orderDirection}\n        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}\n      `;\n      params.push(limit, offset);\n\n      const result = await client.query(sqlQuery, params);\n\n      return result.rows.map((row) => ({\n        namespace: row.namespace_path.split(\":\"),\n        key: row.key,\n        value: row.value,\n        createdAt: row.created_at || new Date(),\n        updatedAt: row.updated_at || new Date(),\n        score: parseFloat(row.similarity_score),\n      }));\n    });\n  }\n\n  async hybridSearch(\n    namespacePrefix: string[],\n    query: string,\n    options: {\n      filter?: Record<string, unknown>;\n      limit?: number;\n      offset?: number;\n      vectorWeight?: number; // 0.0 to 1.0, weight for vector search vs text search\n      similarityThreshold?: number;\n    } = {}\n  ): Promise<SearchItem[]> {\n    if (!this.core.indexConfig) {\n      throw new Error(\n        \"Vector search not configured. Please provide an IndexConfig when creating the store.\"\n      );\n    }\n\n    return this.core.withClient(async (client) => {\n      validateNamespace(namespacePrefix);\n\n      const namespacePath = namespacePrefix.join(\":\");\n      const {\n        filter,\n        limit = 10,\n        offset = 0,\n        vectorWeight = 0.7,\n        similarityThreshold = 0.0,\n      } = options;\n\n      // Generate query embedding\n      const queryEmbedding = await this.vectorOps.generateQueryEmbedding(query);\n\n      if (queryEmbedding.length !== this.core.indexConfig!.dims) {\n        throw new Error(\n          `Query embedding dimension mismatch: expected ${\n            this.core.indexConfig!.dims\n          }, got ${queryEmbedding.length}`\n        );\n      }\n\n      let sqlQuery = `\n        SELECT DISTINCT \n          s.namespace_path, \n          s.key, \n          s.value, \n          s.created_at, \n          s.updated_at,\n          (\n            $3 * (1 - MIN(v.embedding <=> $2)) + \n            (1 - $3) * ts_rank(to_tsvector($6::regconfig, s.value::text), plainto_tsquery($6::regconfig, $4))\n          ) as hybrid_score\n        FROM ${this.core.schema}.store s\n        JOIN ${this.core.schema}.store_vectors v ON s.namespace_path = v.namespace_path AND s.key = v.key\n        WHERE s.namespace_path LIKE $1\n          AND (s.expires_at IS NULL OR s.expires_at > CURRENT_TIMESTAMP)\n          AND (\n            to_tsvector($6::regconfig, s.value::text) @@ plainto_tsquery($6::regconfig, $4)\n            OR v.embedding <=> $2 <= $5\n          )\n      `;\n\n      const params: unknown[] = [\n        `${namespacePath}%`,\n        `[${queryEmbedding.join(\",\")}]`,\n        vectorWeight,\n        query,\n        1 - similarityThreshold,\n        this.core.textSearchLanguage,\n      ];\n      let paramIndex = 7;\n\n      // Add filter conditions\n      if (filter && Object.keys(filter).length > 0) {\n        const { conditions, newParamIndex } =\n          QueryBuilder.buildFilterConditions(filter, params, paramIndex);\n        if (conditions.length > 0) {\n          const adjustedConditions = conditions.map((condition: string) =>\n            condition.replace(/value ->/g, \"s.value ->\")\n          );\n          sqlQuery += ` AND (${adjustedConditions.join(\" AND \")})`;\n          paramIndex = newParamIndex;\n        }\n      }\n\n      sqlQuery += ` \n        GROUP BY s.namespace_path, s.key, s.value, s.created_at, s.updated_at\n        ORDER BY hybrid_score DESC\n        LIMIT $${paramIndex} OFFSET $${paramIndex + 1}\n      `;\n      params.push(limit, offset);\n\n      const result = await client.query(sqlQuery, params);\n\n      return result.rows.map((row) => ({\n        namespace: row.namespace_path.split(\":\"),\n        key: row.key,\n        value: row.value,\n        createdAt: row.created_at || new Date(),\n        updatedAt: row.updated_at || new Date(),\n        score: parseFloat(row.hybrid_score),\n      }));\n    });\n  }\n}\n"],"mappings":"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"}