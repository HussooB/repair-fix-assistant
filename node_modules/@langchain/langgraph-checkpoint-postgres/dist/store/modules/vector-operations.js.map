{"version":3,"file":"vector-operations.js","names":["core: DatabaseCore","textsToEmbed: { fieldPath: string; text: string }[]","results: string[]"],"sources":["../../../src/store/modules/vector-operations.ts"],"sourcesContent":["import pg from \"pg\";\nimport { DatabaseCore } from \"./database-core.js\";\nimport { Embeddings } from \"./types.js\";\n\n/**\n * Handles vector processing, embeddings, and text extraction.\n */\nexport class VectorOperations {\n  constructor(private core: DatabaseCore) {}\n\n  async indexItemVectors(\n    client: pg.PoolClient,\n    namespacePath: string,\n    key: string,\n    value: Record<string, unknown>,\n    index?: string[] | false\n  ): Promise<void> {\n    // Early exit if vector indexing is not configured or explicitly disabled\n    if (!this.core.indexConfig || index === false) return;\n\n    // Delete existing vectors for this item\n    await client.query(\n      `\n      DELETE FROM ${this.core.schema}.store_vectors \n      WHERE namespace_path = $1 AND key = $2\n    `,\n      [namespacePath, key]\n    );\n\n    // Use provided index fields if specified, otherwise use the configured default\n    const fields = index || this.core.indexConfig.fields || [\"$\"];\n    const textsToEmbed: { fieldPath: string; text: string }[] = [];\n\n    // Extract text from configured fields\n    for (const fieldPath of fields) {\n      const extractedTexts = this.extractTextAtPath(value, fieldPath);\n      extractedTexts.forEach((text, i) => {\n        const trimmedText = text?.trim();\n        if (trimmedText) {\n          const actualFieldPath =\n            extractedTexts.length > 1 ? `${fieldPath}[${i}]` : fieldPath;\n          textsToEmbed.push({ fieldPath: actualFieldPath, text: trimmedText });\n        }\n      });\n    }\n\n    if (textsToEmbed.length === 0) return;\n\n    // Generate embeddings\n    const texts = textsToEmbed.map((item) => item.text);\n    const embeddings = await this.generateEmbeddings(texts);\n\n    // Insert vectors\n    for (let i = 0; i < textsToEmbed.length; i += 1) {\n      const { fieldPath, text } = textsToEmbed[i];\n      const embedding = embeddings[i];\n\n      if (embedding?.length === this.core.indexConfig.dims) {\n        await client.query(\n          `\n          INSERT INTO ${this.core.schema}.store_vectors \n          (namespace_path, key, field_path, text_content, embedding)\n          VALUES ($1, $2, $3, $4, $5)\n        `,\n          [namespacePath, key, fieldPath, text, `[${embedding.join(\",\")}]`]\n        );\n      }\n    }\n  }\n\n  async generateEmbeddings(texts: string[]): Promise<number[][]> {\n    if (!this.core.indexConfig) {\n      throw new Error(\"Vector search not configured\");\n    }\n\n    const { embed } = this.core.indexConfig;\n\n    if (typeof embed === \"function\") {\n      return await embed(texts);\n    }\n\n    // LangChain Embeddings interface\n    if (embed && typeof embed === \"object\" && \"embedDocuments\" in embed) {\n      return await (embed as Embeddings).embedDocuments(texts);\n    }\n\n    throw new Error(\"Invalid embedding configuration\");\n  }\n\n  async generateQueryEmbedding(text: string): Promise<number[]> {\n    if (!this.core.indexConfig) {\n      throw new Error(\"Vector search not configured\");\n    }\n\n    const { embed } = this.core.indexConfig;\n\n    if (typeof embed === \"function\") {\n      const embeddings = await embed([text]);\n      return embeddings[0] || [];\n    }\n\n    // LangChain Embeddings interface\n    if (embed && typeof embed === \"object\" && \"embedQuery\" in embed) {\n      return await (embed as Embeddings).embedQuery(text);\n    }\n\n    if (embed && typeof embed === \"object\" && \"embedDocuments\" in embed) {\n      const embeddings = await (embed as Embeddings).embedDocuments([text]);\n      return embeddings[0] || [];\n    }\n\n    throw new Error(\"Invalid embedding configuration\");\n  }\n\n  private extractTextAtPath(obj: unknown, path: string): string[] {\n    if (path === \"$\") {\n      return [JSON.stringify(obj)];\n    }\n\n    const parts = path.split(\".\");\n    let current = obj;\n    const results: string[] = [];\n\n    try {\n      for (let i = 0; i < parts.length; i += 1) {\n        const part = parts[i];\n\n        if (part.includes(\"[\")) {\n          const [field, arrayPart] = part.split(\"[\");\n          const arrayIndex = arrayPart.replace(\"]\", \"\");\n\n          if (field && typeof current === \"object\" && current !== null) {\n            current = (current as Record<string, unknown>)[field];\n          }\n\n          if (arrayIndex === \"*\") {\n            if (Array.isArray(current)) {\n              const remainingPath = parts.slice(i + 1).join(\".\");\n\n              if (remainingPath) {\n                for (const item of current) {\n                  if (item != null) {\n                    results.push(\n                      ...this.extractTextAtPath(item, remainingPath)\n                    );\n                  }\n                }\n              } else {\n                for (const item of current) {\n                  if (typeof item === \"string\") {\n                    results.push(item);\n                  } else if (typeof item === \"object\" && item !== null) {\n                    results.push(JSON.stringify(item));\n                  } else if (item != null) {\n                    results.push(String(item));\n                  }\n                }\n              }\n            }\n            return results;\n          } else if (arrayIndex === \"-1\") {\n            if (Array.isArray(current) && current.length > 0) {\n              current = current[current.length - 1];\n            }\n          } else {\n            const index = parseInt(arrayIndex, 10);\n            if (\n              Array.isArray(current) &&\n              index >= 0 &&\n              index < current.length\n            ) {\n              current = current[index];\n            }\n          }\n        } else if (typeof current === \"object\" && current !== null) {\n          current = (current as Record<string, unknown>)[part];\n        }\n\n        if (current == null) return [];\n      }\n\n      if (typeof current === \"string\") {\n        results.push(current);\n      } else if (typeof current === \"object\" && current !== null) {\n        results.push(JSON.stringify(current));\n      } else {\n        results.push(String(current));\n      }\n    } catch (error) {\n      return [];\n    }\n\n    return results;\n  }\n}\n"],"mappings":"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"}