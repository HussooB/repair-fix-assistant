import { DatabaseCore } from "./modules/database-core.js";
import { VectorOperations } from "./modules/vector-operations.js";
import { CrudOperations } from "./modules/crud-operations.js";
import { SearchOperations } from "./modules/search-operations.js";
import { TTLManager } from "./modules/ttl-manager.js";
import { getStoreTablesWithSchema } from "./sql.js";
import { getStoreMigrations } from "./store-migrations.js";
import { BaseStore } from "@langchain/langgraph-checkpoint";
import pg from "pg";

//#region src/store/index.ts
const { Pool } = pg;
/**
* PostgreSQL implementation of the BaseStore interface.
* This is now a lightweight orchestrator that delegates to specialized modules.
*/
var PostgresStore = class PostgresStore extends BaseStore {
	core;
	vectorOps;
	crudOps;
	searchOps;
	ttlManager;
	isSetup = false;
	isClosed = false;
	ensureTables;
	constructor(config) {
		super();
		const pool = typeof config.connectionOptions === "string" ? new Pool({ connectionString: config.connectionOptions }) : new Pool(config.connectionOptions);
		this.core = new DatabaseCore(pool, config.schema || "public", config.ttl, config.index, config.textSearchLanguage);
		this.vectorOps = new VectorOperations(this.core);
		this.crudOps = new CrudOperations(this.core, this.vectorOps);
		this.searchOps = new SearchOperations(this.core, this.vectorOps);
		this.ttlManager = new TTLManager(this.core);
		this.ensureTables = config.ensureTables ?? true;
	}
	/**
	* Put an item with optional indexing configuration and TTL.
	*/
	async put(namespace, key, value, index, options) {
		if (!this.isSetup && this.ensureTables) await this.setup();
		return this.core.withClient(async (client) => {
			const operation = {
				namespace,
				key,
				value,
				index,
				options
			};
			await this.crudOps.executePut(client, operation);
		});
	}
	/**
	* Get an item by namespace and key.
	*/
	async get(namespace, key) {
		if (!this.isSetup && this.ensureTables) await this.setup();
		return this.core.withClient(async (client) => {
			return this.crudOps.executeGet(client, {
				namespace,
				key
			});
		});
	}
	/**
	* Delete an item by namespace and key.
	*/
	async delete(namespace, key) {
		if (!this.isSetup && this.ensureTables) await this.setup();
		return this.core.withClient(async (client) => {
			const operation = {
				namespace,
				key,
				value: null
			};
			await this.crudOps.executePut(client, operation);
		});
	}
	/**
	* List namespaces with optional filtering.
	*/
	async listNamespaces(options = {}) {
		if (!this.isSetup && this.ensureTables) await this.setup();
		const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;
		const matchConditions = [];
		if (prefix) matchConditions.push({
			matchType: "prefix",
			path: prefix
		});
		if (suffix) matchConditions.push({
			matchType: "suffix",
			path: suffix
		});
		const operation = {
			matchConditions,
			maxDepth,
			limit,
			offset
		};
		return this.core.withClient(async (client) => {
			return this.executeListNamespaces(client, operation);
		});
	}
	/**
	* Creates a PostgresStore instance from a connection string.
	*/
	static fromConnString(connectionString, options) {
		return new PostgresStore({
			connectionOptions: connectionString,
			...options
		});
	}
	/**
	* Initialize the store by running migrations to create necessary tables and indexes.
	*/
	async setup() {
		if (this.isSetup) return;
		await this.runStoreMigrations();
		this.isSetup = true;
		if (this.core.ttlConfig?.sweepIntervalMinutes) this.ttlManager.start();
	}
	/**
	* Run store migrations to set up the database schema
	*/
	async runStoreMigrations() {
		const client = await this.core.pool.connect();
		const STORE_TABLES = getStoreTablesWithSchema(this.core.schema);
		try {
			await client.query(`CREATE SCHEMA IF NOT EXISTS ${this.core.schema}`);
			let version = -1;
			const migrationConfig = {
				schema: this.core.schema,
				indexConfig: this.core.indexConfig ? {
					dims: this.core.indexConfig.dims,
					indexType: this.core.indexConfig.indexType,
					distanceMetric: this.core.indexConfig.distanceMetric,
					createAllMetricIndexes: this.core.indexConfig.createAllMetricIndexes,
					hnsw: this.core.indexConfig.hnsw,
					ivfflat: this.core.indexConfig.ivfflat
				} : void 0
			};
			const migrations = getStoreMigrations(migrationConfig);
			try {
				const result = await client.query(`SELECT v FROM ${STORE_TABLES.store_migrations} ORDER BY v DESC LIMIT 1`);
				if (result.rows.length > 0) version = result.rows[0].v;
			} catch (error) {
				if (typeof error === "object" && error !== null && "code" in error && typeof error.code === "string" && error.code === "42P01") version = -1;
				else throw error;
			}
			for (let v = version + 1; v < migrations.length; v += 1) {
				await client.query(migrations[v]);
				await client.query(`INSERT INTO ${STORE_TABLES.store_migrations} (v) VALUES ($1)`, [v]);
			}
		} finally {
			client.release();
		}
	}
	/**
	* Execute multiple operations in a single batch.
	*/
	async batch(operations) {
		if (!this.isSetup && this.ensureTables) await this.setup();
		return this.core.withClient(async (client) => {
			const results = [];
			for (const operation of operations) if ("namespacePrefix" in operation) results.push(await this.searchOps.executeSearch(client, operation));
			else if ("key" in operation && !("value" in operation)) results.push(await this.crudOps.executeGet(client, operation));
			else if ("value" in operation) results.push(await this.crudOps.executePut(client, operation));
			else if ("matchConditions" in operation) results.push(await this.executeListNamespaces(client, operation));
			else throw new Error(`Unsupported operation type: ${JSON.stringify(operation)}`);
			return results;
		});
	}
	async executeListNamespaces(client, operation) {
		const { matchConditions, maxDepth, limit = 100, offset = 0 } = operation;
		let sqlQuery = `
      SELECT DISTINCT namespace_path
      FROM ${this.core.schema}.store
    `;
		const params = [];
		const conditions = [];
		let paramIndex = 1;
		if (matchConditions && matchConditions.length > 0) {
			for (const condition of matchConditions) if (condition.matchType === "prefix") {
				const prefix = condition.path.join(":");
				conditions.push(`namespace_path LIKE $${paramIndex}`);
				params.push(`${prefix}%`);
				paramIndex += 1;
			} else if (condition.matchType === "suffix") {
				const suffix = condition.path.join(":");
				conditions.push(`namespace_path LIKE $${paramIndex}`);
				params.push(`%${suffix}`);
				paramIndex += 1;
			}
		}
		if (conditions.length > 0) sqlQuery += ` WHERE ${conditions.join(" AND ")}`;
		sqlQuery += ` ORDER BY namespace_path LIMIT $${paramIndex} OFFSET $${paramIndex + 1}`;
		params.push(limit, offset);
		const result = await client.query(sqlQuery, params);
		let namespaces = result.rows.map((row) => row.namespace_path.split(":"));
		if (maxDepth !== void 0) namespaces = namespaces.filter((ns) => ns.length <= maxDepth);
		return namespaces;
	}
	/**
	* Start the store. Calls setup() if ensureTables is true.
	*/
	async start() {
		if (this.ensureTables && !this.isSetup) await this.setup();
	}
	/**
	* Stop the store and close all database connections.
	*/
	async stop() {
		if (this.isClosed) return;
		this.ttlManager.stop();
		await this.core.pool.end();
		this.isClosed = true;
	}
	/**
	* Manually sweep expired items from the store.
	*/
	async sweepExpiredItems() {
		if (!this.isSetup && this.ensureTables) await this.setup();
		return this.ttlManager.sweepExpiredItems();
	}
	/**
	* Enhanced search with advanced filtering and similarity scoring.
	* @private Internal method used by search.
	*/
	async textSearch(namespacePrefix, options = {}) {
		return this.searchOps.textSearch(namespacePrefix, options);
	}
	/**
	* Get statistics about the store.
	*/
	async getStats() {
		if (!this.isSetup && this.ensureTables) await this.setup();
		return this.core.withClient(async (client) => {
			const result = await client.query(`
        SELECT 
          COUNT(*) as total_items,
          COUNT(CASE WHEN expires_at IS NOT NULL AND expires_at <= CURRENT_TIMESTAMP THEN 1 END) as expired_items,
          COUNT(DISTINCT namespace_path) as namespace_count,
          MIN(created_at) as oldest_item,
          MAX(created_at) as newest_item
        FROM ${this.core.schema}.store
      `);
			const row = result.rows[0];
			return {
				totalItems: parseInt(row.total_items, 10),
				expiredItems: parseInt(row.expired_items, 10),
				namespaceCount: parseInt(row.namespace_count, 10),
				oldestItem: row.oldest_item,
				newestItem: row.newest_item
			};
		});
	}
	/**
	* Performs vector similarity search using embeddings.
	*
	* @param namespacePrefix - The namespace prefix to search within
	* @param query - The text query to embed and search for similar items
	* @param options - Search options including filter, similarity threshold, and distance metric
	* @returns Promise resolving to an array of search results with similarity scores
	*/
	async vectorSearch(namespacePrefix, query, options = {}) {
		if (!this.isSetup && this.ensureTables) await this.setup();
		if (!this.core.indexConfig) throw new Error("Vector search not configured. Please provide an IndexConfig when creating the store.");
		return this.searchOps.vectorSearch(namespacePrefix, query, options);
	}
	/**
	* Performs hybrid search combining vector similarity and text search.
	*
	* @param namespacePrefix - The namespace prefix to search within
	* @param query - The text query to search for
	* @param options - Search options including filter, vector weight, and similarity threshold
	* @returns Promise resolving to an array of search results with combined similarity scores
	*/
	async hybridSearch(namespacePrefix, query, options = {}) {
		if (!this.isSetup && this.ensureTables) await this.setup();
		if (!this.core.indexConfig) throw new Error("Vector search not configured. Please provide an IndexConfig when creating the store.");
		return this.searchOps.hybridSearch(namespacePrefix, query, options);
	}
	/**
	* Search for items in the store with support for text search, vector search, and filtering.
	*
	* @param namespacePrefix - The namespace prefix to search within
	* @param options - Search options including search mode, filters, query text, and pagination
	* @returns Promise resolving to an array of search results with optional similarity scores
	*
	* @example
	* ```typescript
	* // Basic text search
	* const results = await store.search(["documents"], {
	*   query: "machine learning",
	*   mode: "text"
	* });
	*
	* // Vector search
	* const results = await store.search(["documents"], {
	*   query: "machine learning",
	*   mode: "vector",
	*   similarityThreshold: 0.7
	* });
	*
	* // Hybrid search (combining vector and text)
	* const results = await store.search(["documents"], {
	*   query: "machine learning",
	*   mode: "hybrid",
	*   vectorWeight: 0.7
	* });
	*
	* // Filtered search
	* const results = await store.search(["products"], {
	*   filter: { category: "electronics", price: { $lt: 100 } }
	* });
	* ```
	*/
	async search(namespacePrefix, options = {}) {
		if (!this.isSetup && this.ensureTables) await this.setup();
		const { mode = "auto", query,...restOptions } = options;
		if (!query) return this.textSearch(namespacePrefix, restOptions);
		const hasVectorSearch = Boolean(this.core.indexConfig);
		let effectiveMode = mode;
		if (mode === "auto") effectiveMode = hasVectorSearch ? "vector" : "text";
		switch (effectiveMode) {
			case "vector":
				if (!hasVectorSearch) throw new Error("Vector search requested but not configured. Please provide an IndexConfig when creating the store.");
				return this.vectorSearch(namespacePrefix, query, {
					...restOptions,
					similarityThreshold: options.similarityThreshold,
					distanceMetric: options.distanceMetric
				});
			case "hybrid":
				if (!hasVectorSearch) throw new Error("Hybrid search requested but vector search not configured. Please provide an IndexConfig when creating the store.");
				return this.hybridSearch(namespacePrefix, query, {
					...restOptions,
					vectorWeight: options.vectorWeight,
					similarityThreshold: options.similarityThreshold
				});
			case "text": return this.textSearch(namespacePrefix, {
				query,
				...restOptions
			});
			default: throw new Error(`Unknown search mode: ${mode}`);
		}
	}
};

//#endregion
export { PostgresStore };
//# sourceMappingURL=index.js.map