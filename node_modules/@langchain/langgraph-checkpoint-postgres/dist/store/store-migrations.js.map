{"version":3,"file":"store-migrations.js","names":["metricsToIndex: DistanceMetric[]","metricSuffix: string","vectorIndexSql: string"],"sources":["../../src/store/store-migrations.ts"],"sourcesContent":["import { getStoreTablesWithSchema } from \"./sql.js\";\nimport { VectorIndexType, DistanceMetric } from \"./modules/types.js\";\n\n/**\n * Store migration configuration\n */\nexport interface StoreMigrationConfig {\n  schema: string;\n  indexConfig?: {\n    dims: number;\n    indexType?: VectorIndexType;\n    distanceMetric?: DistanceMetric;\n    createAllMetricIndexes?: boolean;\n    hnsw?: { m?: number; efConstruction?: number };\n    ivfflat?: { lists?: number };\n  };\n}\n\n/**\n * To add a new store migration, add a new string to the list returned by the getStoreMigrations function.\n * The position of the migration in the list is the version number.\n */\nexport const getStoreMigrations = (config: StoreMigrationConfig): string[] => {\n  const { schema, indexConfig } = config;\n  const STORE_TABLES = getStoreTablesWithSchema(schema);\n  const migrations = [];\n\n  // Migration 1: Create store migrations table\n  migrations.push(`CREATE TABLE IF NOT EXISTS ${STORE_TABLES.store_migrations} (\n    v INTEGER PRIMARY KEY\n  );`);\n\n  // Migration 2: Create main store table\n  migrations.push(`CREATE TABLE IF NOT EXISTS ${STORE_TABLES.store} (\n    namespace_path TEXT NOT NULL,\n    key TEXT NOT NULL,\n    value JSONB NOT NULL,\n    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n    expires_at TIMESTAMPTZ,\n    PRIMARY KEY (namespace_path, key)\n  );`);\n\n  // Migration 3: Create basic indexes\n  migrations.push(`\n    CREATE INDEX IF NOT EXISTS idx_store_namespace_path \n    ON ${STORE_TABLES.store} USING btree (namespace_path);\n    \n    CREATE INDEX IF NOT EXISTS idx_store_value_gin \n    ON ${STORE_TABLES.store} USING gin (value);\n    \n    CREATE INDEX IF NOT EXISTS idx_store_expires_at \n    ON ${STORE_TABLES.store} USING btree (expires_at) \n    WHERE expires_at IS NOT NULL;\n  `);\n\n  // Migration 4: Create update trigger\n  migrations.push(`\n    CREATE OR REPLACE FUNCTION ${schema}.update_updated_at_column()\n    RETURNS TRIGGER AS $$\n    BEGIN\n      NEW.updated_at = CURRENT_TIMESTAMP;\n      RETURN NEW;\n    END;\n    $$ language 'plpgsql';\n\n    DROP TRIGGER IF EXISTS update_store_updated_at ON ${STORE_TABLES.store};\n\n    CREATE TRIGGER update_store_updated_at\n    BEFORE UPDATE ON ${STORE_TABLES.store}\n    FOR EACH ROW EXECUTE FUNCTION ${schema}.update_updated_at_column();\n  `);\n\n  // Vector-related migrations (only if indexConfig is provided)\n  if (indexConfig) {\n    // Migration 5: Enable vector extension\n    migrations.push(`CREATE EXTENSION IF NOT EXISTS vector;`);\n\n    // Migration 6: Create vector table\n    migrations.push(`CREATE TABLE IF NOT EXISTS ${STORE_TABLES.store_vectors} (\n      namespace_path TEXT NOT NULL,\n      key TEXT NOT NULL,\n      field_path TEXT NOT NULL,\n      text_content TEXT NOT NULL,\n      embedding vector(${indexConfig.dims}) NOT NULL,\n      created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,\n      PRIMARY KEY (namespace_path, key, field_path),\n      FOREIGN KEY (namespace_path, key) REFERENCES ${STORE_TABLES.store}(namespace_path, key) ON DELETE CASCADE\n    );`);\n\n    // Migration 7: Create vector indexes\n    const {\n      indexType = \"hnsw\",\n      distanceMetric = \"cosine\",\n      createAllMetricIndexes = false,\n    } = indexConfig;\n    const metricsToIndex: DistanceMetric[] = createAllMetricIndexes\n      ? [\"cosine\", \"l2\", \"inner_product\"]\n      : [distanceMetric];\n\n    for (const metric of metricsToIndex) {\n      let metricSuffix: string;\n      if (metric === \"cosine\") {\n        metricSuffix = \"cosine\";\n      } else if (metric === \"l2\") {\n        metricSuffix = \"l2\";\n      } else {\n        metricSuffix = \"ip\";\n      }\n\n      const indexName = `idx_store_vectors_embedding_${metricSuffix}_${indexType}`;\n\n      const operatorClassMap = {\n        cosine: \"vector_cosine_ops\",\n        l2: \"vector_l2_ops\",\n        inner_product: \"vector_ip_ops\",\n      } as const;\n      const operatorClass = operatorClassMap[metric];\n\n      let vectorIndexSql: string;\n      if (indexType === \"hnsw\") {\n        const m = indexConfig.hnsw?.m || 16;\n        const efConstruction = indexConfig.hnsw?.efConstruction || 200;\n        vectorIndexSql = `CREATE INDEX IF NOT EXISTS ${indexName}\n          ON ${STORE_TABLES.store_vectors} USING hnsw (embedding ${operatorClass})\n          WITH (m = ${m}, ef_construction = ${efConstruction});`;\n      } else if (indexType === \"ivfflat\") {\n        const lists = indexConfig.ivfflat?.lists || 100;\n        vectorIndexSql = `CREATE INDEX IF NOT EXISTS ${indexName}\n          ON ${STORE_TABLES.store_vectors} USING ivfflat (embedding ${operatorClass})\n          WITH (lists = ${lists});`;\n      } else {\n        throw new Error(`Unsupported vector index type: ${indexType}`);\n      }\n\n      migrations.push(vectorIndexSql);\n    }\n  }\n\n  return migrations;\n};\n"],"mappings":";;;;;;;AAsBA,MAAa,sBAAsB,WAA2C;CAC5E,MAAM,EAAE,QAAQ,gBAAgB;CAChC,MAAM,eAAe,yBAAyB;CAC9C,MAAM,aAAa;AAGnB,YAAW,KAAK,8BAA8B,aAAa,iBAAiB;;;AAK5E,YAAW,KAAK,8BAA8B,aAAa,MAAM;;;;;;;;;AAWjE,YAAW,KAAK;;SAET,aAAa,MAAM;;;SAGnB,aAAa,MAAM;;;SAGnB,aAAa,MAAM;;;AAK1B,YAAW,KAAK;iCACe,OAAO;;;;;;;;wDAQgB,aAAa,MAAM;;;uBAGpD,aAAa,MAAM;oCACN,OAAO;;AAIzC,KAAI,aAAa;AAEf,aAAW,KAAK;AAGhB,aAAW,KAAK,8BAA8B,aAAa,cAAc;;;;;yBAKpD,YAAY,KAAK;;;qDAGW,aAAa,MAAM;;EAIpE,MAAM,EACJ,YAAY,QACZ,iBAAiB,UACjB,yBAAyB,UACvB;EACJ,MAAMA,iBAAmC,yBACrC;GAAC;GAAU;GAAM;MACjB,CAAC;AAEL,OAAK,MAAM,UAAU,gBAAgB;GACnC,IAAIC;AACJ,OAAI,WAAW,SACb,gBAAe;YACN,WAAW,KACpB,gBAAe;OAEf,gBAAe;GAGjB,MAAM,YAAY,+BAA+B,aAAa,GAAG;GAEjE,MAAM,mBAAmB;IACvB,QAAQ;IACR,IAAI;IACJ,eAAe;;GAEjB,MAAM,gBAAgB,iBAAiB;GAEvC,IAAIC;AACJ,OAAI,cAAc,QAAQ;IACxB,MAAM,IAAI,YAAY,MAAM,KAAK;IACjC,MAAM,iBAAiB,YAAY,MAAM,kBAAkB;AAC3D,qBAAiB,8BAA8B,UAAU;eAClD,aAAa,cAAc,yBAAyB,cAAc;sBAC3D,EAAE,sBAAsB,eAAe;cAC5C,cAAc,WAAW;IAClC,MAAM,QAAQ,YAAY,SAAS,SAAS;AAC5C,qBAAiB,8BAA8B,UAAU;eAClD,aAAa,cAAc,4BAA4B,cAAc;0BAC1D,MAAM;SAExB,OAAM,IAAI,MAAM,kCAAkC;AAGpD,cAAW,KAAK;;;AAIpB,QAAO"}