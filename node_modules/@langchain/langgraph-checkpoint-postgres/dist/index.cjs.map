{"version":3,"file":"index.cjs","names":["_defaultOptions: PostgresSaverOptions","BaseCheckpointSaver","getSQLStatements","getTablesWithSchema","getMigrations","error: unknown","serialized: Record<string, unknown>","WRITES_IDX_MAP","wheres: string[]","paramValues: unknown[]","args: unknown[]","where: string","enc","blob","TASKS"],"sources":["../src/index.ts"],"sourcesContent":["import type { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  BaseCheckpointSaver,\n  type Checkpoint,\n  type CheckpointListOptions,\n  type CheckpointTuple,\n  type SerializerProtocol,\n  type PendingWrite,\n  type CheckpointMetadata,\n  type ChannelVersions,\n  WRITES_IDX_MAP,\n  TASKS,\n  maxChannelVersion,\n} from \"@langchain/langgraph-checkpoint\";\nimport pg from \"pg\";\n\nimport { getMigrations } from \"./migrations.js\";\nimport {\n  type SQL_STATEMENTS,\n  type SQL_TYPES,\n  getSQLStatements,\n  getTablesWithSchema,\n} from \"./sql.js\";\n\n/** @inline */\ninterface PostgresSaverOptions {\n  schema: string;\n}\n\nconst _defaultOptions: PostgresSaverOptions = {\n  schema: \"public\",\n};\n\nconst _ensureCompleteOptions = (\n  options?: Partial<PostgresSaverOptions>\n): PostgresSaverOptions => {\n  return {\n    ...options,\n    schema: options?.schema ?? _defaultOptions.schema,\n  };\n};\n\nconst { Pool } = pg;\n\n/**\n * LangGraph checkpointer that uses a Postgres instance as the backing store.\n * Uses the [node-postgres](https://node-postgres.com/) package internally\n * to connect to a Postgres instance.\n *\n * @example\n * ```\n * import { ChatOpenAI } from \"@langchain/openai\";\n * import { PostgresSaver } from \"@langchain/langgraph-checkpoint-postgres\";\n * import { createReactAgent } from \"@langchain/langgraph/prebuilt\";\n *\n * const checkpointer = PostgresSaver.fromConnString(\n *   \"postgresql://user:password@localhost:5432/db\",\n *   // optional configuration object\n *   {\n *     schema: \"custom_schema\" // defaults to \"public\"\n *   }\n * );\n *\n * // NOTE: you need to call .setup() the first time you're using your checkpointer\n * await checkpointer.setup();\n *\n * const graph = createReactAgent({\n *   tools: [getWeather],\n *   llm: new ChatOpenAI({\n *     model: \"gpt-4o-mini\",\n *   }),\n *   checkpointSaver: checkpointer,\n * });\n * const config = { configurable: { thread_id: \"1\" } };\n *\n * await graph.invoke({\n *   messages: [{\n *     role: \"user\",\n *     content: \"what's the weather in sf\"\n *   }],\n * }, config);\n * ```\n */\nexport class PostgresSaver extends BaseCheckpointSaver {\n  private readonly pool: pg.Pool;\n\n  private readonly options: PostgresSaverOptions;\n\n  private readonly SQL_STATEMENTS: SQL_STATEMENTS;\n\n  protected isSetup: boolean;\n\n  constructor(\n    pool: pg.Pool,\n    serde?: SerializerProtocol,\n    options?: Partial<PostgresSaverOptions>\n  ) {\n    super(serde);\n    this.pool = pool;\n    this.isSetup = false;\n    this.options = _ensureCompleteOptions(options);\n    this.SQL_STATEMENTS = getSQLStatements(this.options.schema);\n  }\n\n  /**\n   * Creates a new instance of PostgresSaver from a connection string.\n   *\n   * @param {string} connString - The connection string to connect to the Postgres database.\n   * @param {PostgresSaverOptions} [options] - Optional configuration object.\n   * @returns {PostgresSaver} A new instance of PostgresSaver.\n   *\n   * @example\n   * const connString = \"postgresql://user:password@localhost:5432/db\";\n   * const checkpointer = PostgresSaver.fromConnString(connString, {\n   *  schema: \"custom_schema\" // defaults to \"public\"\n   * });\n   * await checkpointer.setup();\n   */\n  static fromConnString(\n    connString: string,\n    options?: Partial<PostgresSaverOptions>\n  ): PostgresSaver {\n    const pool = new Pool({ connectionString: connString });\n    return new PostgresSaver(pool, undefined, options);\n  }\n\n  /**\n   * Set up the checkpoint database asynchronously.\n   *\n   * This method creates the necessary tables in the Postgres database if they don't\n   * already exist and runs database migrations. It MUST be called directly by the user\n   * the first time checkpointer is used.\n   */\n  async setup(): Promise<void> {\n    const client = await this.pool.connect();\n    const SCHEMA_TABLES = getTablesWithSchema(this.options.schema);\n    try {\n      await client.query(`CREATE SCHEMA IF NOT EXISTS ${this.options.schema}`);\n      let version = -1;\n      const MIGRATIONS = getMigrations(this.options.schema);\n\n      try {\n        const result = await client.query(\n          `SELECT v FROM ${SCHEMA_TABLES.checkpoint_migrations} ORDER BY v DESC LIMIT 1`\n        );\n        if (result.rows.length > 0) {\n          version = result.rows[0].v;\n        }\n      } catch (error: unknown) {\n        // Assume table doesn't exist if there's an error\n        if (\n          typeof error === \"object\" &&\n          error !== null &&\n          \"code\" in error &&\n          typeof error.code === \"string\" &&\n          error.code === \"42P01\" // Postgres error code for undefined_table\n        ) {\n          version = -1;\n        } else {\n          throw error;\n        }\n      }\n\n      for (let v = version + 1; v < MIGRATIONS.length; v += 1) {\n        await client.query(MIGRATIONS[v]);\n        await client.query(\n          `INSERT INTO ${SCHEMA_TABLES.checkpoint_migrations} (v) VALUES ($1)`,\n          [v]\n        );\n      }\n    } finally {\n      client.release();\n    }\n  }\n\n  protected async _loadCheckpoint(\n    checkpoint: Omit<Checkpoint, \"pending_sends\" | \"channel_values\">,\n    channelValues: [Uint8Array, Uint8Array, Uint8Array][]\n  ): Promise<Checkpoint> {\n    return {\n      ...checkpoint,\n      channel_values: await this._loadBlobs(channelValues),\n    };\n  }\n\n  protected async _loadBlobs(\n    blobValues: [Uint8Array, Uint8Array, Uint8Array][]\n  ): Promise<Record<string, unknown>> {\n    if (!blobValues || blobValues.length === 0) {\n      return {};\n    }\n    const textDecoder = new TextDecoder();\n    const entries = await Promise.all(\n      blobValues\n        .filter(([, t]) => textDecoder.decode(t) !== \"empty\")\n        .map(async ([k, t, v]) => [\n          textDecoder.decode(k),\n          await this.serde.loadsTyped(textDecoder.decode(t), v),\n        ])\n    );\n    return Object.fromEntries(entries);\n  }\n\n  protected async _loadMetadata(metadata: Record<string, unknown>) {\n    const [type, dumpedValue] = await this.serde.dumpsTyped(metadata);\n    return this.serde.loadsTyped(type, dumpedValue);\n  }\n\n  protected async _loadWrites(\n    writes: [Uint8Array, Uint8Array, Uint8Array, Uint8Array][]\n  ): Promise<[string, string, unknown][]> {\n    const decoder = new TextDecoder();\n    return writes\n      ? await Promise.all(\n          writes.map(async ([tid, channel, t, v]) => [\n            decoder.decode(tid),\n            decoder.decode(channel),\n            await this.serde.loadsTyped(decoder.decode(t), v),\n          ])\n        )\n      : [];\n  }\n\n  protected async _dumpBlobs(\n    threadId: string,\n    checkpointNs: string,\n    values: Record<string, unknown>,\n    versions: ChannelVersions\n  ): Promise<\n    [string, string, string, string, string, Uint8Array | undefined][]\n  > {\n    if (Object.keys(versions).length === 0) {\n      return [];\n    }\n\n    return Promise.all(\n      Object.entries(versions).map(async ([k, ver]) => {\n        const [type, value] =\n          k in values\n            ? await this.serde.dumpsTyped(values[k])\n            : [\"empty\", null];\n        return [\n          threadId,\n          checkpointNs,\n          k,\n          ver.toString(),\n          type,\n          value ? new Uint8Array(value) : undefined,\n        ];\n      })\n    );\n  }\n\n  protected _dumpCheckpoint(checkpoint: Checkpoint) {\n    const serialized: Record<string, unknown> = { ...checkpoint };\n    if (\"channel_values\" in serialized) delete serialized.channel_values;\n    return serialized;\n  }\n\n  protected async _dumpMetadata(metadata: CheckpointMetadata) {\n    const [, serializedMetadata] = await this.serde.dumpsTyped(metadata);\n    // We need to remove null characters before writing\n    return JSON.parse(\n      new TextDecoder().decode(serializedMetadata).replace(/\\0/g, \"\")\n    );\n  }\n\n  protected async _dumpWrites(\n    threadId: string,\n    checkpointNs: string,\n    checkpointId: string,\n    taskId: string,\n    writes: [string, unknown][]\n  ): Promise<\n    [string, string, string, string, number, string, string, Uint8Array][]\n  > {\n    return Promise.all(\n      writes.map(async ([channel, value], idx) => {\n        const [type, serializedValue] = await this.serde.dumpsTyped(value);\n        return [\n          threadId,\n          checkpointNs,\n          checkpointId,\n          taskId,\n          WRITES_IDX_MAP[channel] ?? idx,\n          channel,\n          type,\n          new Uint8Array(serializedValue),\n        ];\n      })\n    );\n  }\n\n  /**\n   * Return WHERE clause predicates for a given list() config, filter, cursor.\n   *\n   * This method returns a tuple of a string and a tuple of values. The string\n   * is the parameterized WHERE clause predicate (including the WHERE keyword):\n   * \"WHERE column1 = $1 AND column2 IS $2\". The list of values contains the\n   * values for each of the corresponding parameters.\n   */\n  protected _searchWhere(\n    config?: RunnableConfig,\n    filter?: Record<string, unknown>,\n    before?: RunnableConfig\n  ): [string, unknown[]] {\n    const wheres: string[] = [];\n    const paramValues: unknown[] = [];\n\n    // construct predicate for config filter\n    if (config?.configurable?.thread_id) {\n      wheres.push(`thread_id = $${paramValues.length + 1}`);\n      paramValues.push(config.configurable.thread_id);\n    }\n\n    // strict checks for undefined/null because empty strings are falsy\n    if (\n      config?.configurable?.checkpoint_ns !== undefined &&\n      config?.configurable?.checkpoint_ns !== null\n    ) {\n      wheres.push(`checkpoint_ns = $${paramValues.length + 1}`);\n      paramValues.push(config.configurable.checkpoint_ns);\n    }\n\n    if (config?.configurable?.checkpoint_id) {\n      wheres.push(`checkpoint_id = $${paramValues.length + 1}`);\n      paramValues.push(config.configurable.checkpoint_id);\n    }\n\n    // construct predicate for metadata filter\n    if (filter && Object.keys(filter).length > 0) {\n      wheres.push(`metadata @> $${paramValues.length + 1}`);\n      paramValues.push(JSON.stringify(filter));\n    }\n\n    // construct predicate for `before`\n    if (before?.configurable?.checkpoint_id !== undefined) {\n      wheres.push(`checkpoint_id < $${paramValues.length + 1}`);\n      paramValues.push(before.configurable.checkpoint_id);\n    }\n\n    return [\n      wheres.length > 0 ? `WHERE ${wheres.join(\" AND \")}` : \"\",\n      paramValues,\n    ];\n  }\n\n  /**\n   * Get a checkpoint tuple from the database.\n   * This method retrieves a checkpoint tuple from the Postgres database\n   * based on the provided config. If the config's configurable field contains\n   * a \"checkpoint_id\" key, the checkpoint with the matching thread_id and\n   * namespace is retrieved. Otherwise, the latest checkpoint for the given\n   * thread_id is retrieved.\n   * @param config The config to use for retrieving the checkpoint.\n   * @returns The retrieved checkpoint tuple, or undefined.\n   */\n  async getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined> {\n    const {\n      thread_id,\n      checkpoint_ns = \"\",\n      checkpoint_id,\n    } = config.configurable ?? {};\n\n    let args: unknown[];\n    let where: string;\n    if (checkpoint_id) {\n      where =\n        \"WHERE thread_id = $1 AND checkpoint_ns = $2 AND checkpoint_id = $3\";\n      args = [thread_id, checkpoint_ns, checkpoint_id];\n    } else {\n      where =\n        \"WHERE thread_id = $1 AND checkpoint_ns = $2 ORDER BY checkpoint_id DESC LIMIT 1\";\n      args = [thread_id, checkpoint_ns];\n    }\n\n    const result = await this.pool.query<SQL_TYPES[\"SELECT_SQL\"]>(\n      this.SQL_STATEMENTS.SELECT_SQL + where,\n      args\n    );\n\n    const [row] = result.rows;\n    if (row === undefined) return undefined;\n\n    if (row.checkpoint.v < 4 && row.parent_checkpoint_id != null) {\n      const sendsResult = await this.pool.query<\n        SQL_TYPES[\"SELECT_PENDING_SENDS_SQL\"]\n      >(this.SQL_STATEMENTS.SELECT_PENDING_SENDS_SQL, [\n        thread_id,\n        [row.parent_checkpoint_id],\n      ]);\n\n      const [sendsRow] = sendsResult.rows;\n      if (sendsRow != null) {\n        await this._migratePendingSends(sendsRow.pending_sends, row);\n      }\n    }\n\n    const checkpoint = await this._loadCheckpoint(\n      row.checkpoint,\n      row.channel_values\n    );\n\n    const finalConfig = {\n      configurable: {\n        thread_id,\n        checkpoint_ns,\n        checkpoint_id: row.checkpoint_id,\n      },\n    };\n    const metadata = await this._loadMetadata(row.metadata);\n    const parentConfig = row.parent_checkpoint_id\n      ? {\n          configurable: {\n            thread_id,\n            checkpoint_ns,\n            checkpoint_id: row.parent_checkpoint_id,\n          },\n        }\n      : undefined;\n    const pendingWrites = await this._loadWrites(row.pending_writes);\n\n    return {\n      config: finalConfig,\n      checkpoint,\n      metadata,\n      parentConfig,\n      pendingWrites,\n    };\n  }\n\n  /**\n   * List checkpoints from the database.\n   *\n   * This method retrieves a list of checkpoint tuples from the Postgres database based\n   * on the provided config. The checkpoints are ordered by checkpoint ID in descending order (newest first).\n   */\n  async *list(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncGenerator<CheckpointTuple> {\n    const { filter, before, limit } = options ?? {};\n    const [where, args] = this._searchWhere(config, filter, before);\n    let query = `${this.SQL_STATEMENTS.SELECT_SQL}${where} ORDER BY checkpoint_id DESC`;\n    if (limit !== undefined) {\n      query += ` LIMIT ${Number.parseInt(limit.toString(), 10)}`; // sanitize via parseInt, as limit could be an externally provided value\n    }\n\n    const result = await this.pool.query<SQL_TYPES[\"SELECT_SQL\"]>(query, args);\n    const toMigrate = result.rows.filter(\n      (row) => row.checkpoint.v < 4 && row.parent_checkpoint_id != null\n    );\n\n    if (toMigrate.length > 0) {\n      const sendsResult = await this.pool.query<\n        SQL_TYPES[\"SELECT_PENDING_SENDS_SQL\"]\n      >(this.SQL_STATEMENTS.SELECT_PENDING_SENDS_SQL, [\n        toMigrate[0].thread_id,\n        toMigrate.map((row) => row.parent_checkpoint_id),\n      ]);\n\n      const parentMap = toMigrate.reduce<\n        Record<string, SQL_TYPES[\"SELECT_SQL\"][]>\n      >((acc, row) => {\n        if (!row.parent_checkpoint_id) return acc;\n\n        acc[row.parent_checkpoint_id] ??= [];\n        acc[row.parent_checkpoint_id].push(row);\n        return acc;\n      }, {});\n\n      // add to values\n      for (const sendsRow of sendsResult.rows) {\n        for (const row of parentMap[sendsRow.checkpoint_id]) {\n          await this._migratePendingSends(sendsRow.pending_sends, row);\n        }\n      }\n    }\n\n    for (const value of result.rows) {\n      yield {\n        config: {\n          configurable: {\n            thread_id: value.thread_id,\n            checkpoint_ns: value.checkpoint_ns,\n            checkpoint_id: value.checkpoint_id,\n          },\n        },\n        checkpoint: await this._loadCheckpoint(\n          value.checkpoint,\n          value.channel_values\n        ),\n        metadata: await this._loadMetadata(value.metadata),\n        parentConfig: value.parent_checkpoint_id\n          ? {\n              configurable: {\n                thread_id: value.thread_id,\n                checkpoint_ns: value.checkpoint_ns,\n                checkpoint_id: value.parent_checkpoint_id,\n              },\n            }\n          : undefined,\n        pendingWrites: await this._loadWrites(value.pending_writes),\n      };\n    }\n  }\n\n  /** @internal */\n  async _migratePendingSends(\n    pendingSends: [Uint8Array, Uint8Array][],\n    mutableRow: {\n      channel_values: [Uint8Array, Uint8Array, Uint8Array][];\n      checkpoint: Omit<Checkpoint, \"pending_sends\" | \"channel_values\">;\n    }\n  ) {\n    const textEncoder = new TextEncoder();\n    const textDecoder = new TextDecoder();\n    const row = mutableRow;\n\n    const [enc, blob] = await this.serde.dumpsTyped(\n      await Promise.all(\n        pendingSends.map(([enc, blob]) =>\n          this.serde.loadsTyped(textDecoder.decode(enc), blob)\n        )\n      )\n    );\n\n    row.channel_values ??= [];\n    row.channel_values.push([\n      textEncoder.encode(TASKS),\n      textEncoder.encode(enc),\n      blob,\n    ]);\n\n    // add to versions\n    row.checkpoint.channel_versions[TASKS] =\n      Object.keys(mutableRow.checkpoint.channel_versions).length > 0\n        ? maxChannelVersion(\n            ...Object.values(mutableRow.checkpoint.channel_versions)\n          )\n        : this.getNextVersion(undefined);\n  }\n\n  /**\n   * Save a checkpoint to the database.\n   *\n   * This method saves a checkpoint to the Postgres database. The checkpoint is associated\n   * with the provided config and its parent config (if any).\n   * @param config\n   * @param checkpoint\n   * @param metadata\n   * @returns\n   */\n  async put(\n    config: RunnableConfig,\n    checkpoint: Checkpoint,\n    metadata: CheckpointMetadata,\n    newVersions: ChannelVersions\n  ): Promise<RunnableConfig> {\n    if (config.configurable === undefined) {\n      throw new Error(`Missing \"configurable\" field in \"config\" param`);\n    }\n    const {\n      thread_id,\n      checkpoint_ns = \"\",\n      checkpoint_id,\n    } = config.configurable;\n\n    const nextConfig = {\n      configurable: {\n        thread_id,\n        checkpoint_ns,\n        checkpoint_id: checkpoint.id,\n      },\n    };\n    const client = await this.pool.connect();\n    const serializedCheckpoint = this._dumpCheckpoint(checkpoint);\n    try {\n      await client.query(\"BEGIN\");\n      const serializedBlobs = await this._dumpBlobs(\n        thread_id,\n        checkpoint_ns,\n        checkpoint.channel_values,\n        newVersions\n      );\n      for (const serializedBlob of serializedBlobs) {\n        await client.query(\n          this.SQL_STATEMENTS.UPSERT_CHECKPOINT_BLOBS_SQL,\n          serializedBlob\n        );\n      }\n      await client.query(this.SQL_STATEMENTS.UPSERT_CHECKPOINTS_SQL, [\n        thread_id,\n        checkpoint_ns,\n        checkpoint.id,\n        checkpoint_id,\n        serializedCheckpoint,\n        await this._dumpMetadata(metadata),\n      ]);\n      await client.query(\"COMMIT\");\n    } catch (e) {\n      await client.query(\"ROLLBACK\");\n      throw e;\n    } finally {\n      client.release();\n    }\n    return nextConfig;\n  }\n\n  /**\n   * Store intermediate writes linked to a checkpoint.\n   *\n   * This method saves intermediate writes associated with a checkpoint to the Postgres database.\n   * @param config Configuration of the related checkpoint.\n   * @param writes List of writes to store.\n   * @param taskId Identifier for the task creating the writes.\n   */\n  async putWrites(\n    config: RunnableConfig,\n    writes: PendingWrite[],\n    taskId: string\n  ): Promise<void> {\n    const query = writes.every((w) => w[0] in WRITES_IDX_MAP)\n      ? this.SQL_STATEMENTS.UPSERT_CHECKPOINT_WRITES_SQL\n      : this.SQL_STATEMENTS.INSERT_CHECKPOINT_WRITES_SQL;\n\n    const dumpedWrites = await this._dumpWrites(\n      config.configurable?.thread_id,\n      config.configurable?.checkpoint_ns,\n      config.configurable?.checkpoint_id,\n      taskId,\n      writes\n    );\n    const client = await this.pool.connect();\n    try {\n      await client.query(\"BEGIN\");\n      for await (const dumpedWrite of dumpedWrites) {\n        await client.query(query, dumpedWrite);\n      }\n      await client.query(\"COMMIT\");\n    } catch (error) {\n      await client.query(\"ROLLBACK\");\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n\n  async end() {\n    return this.pool.end();\n  }\n\n  async deleteThread(threadId: string): Promise<void> {\n    const client = await this.pool.connect();\n    try {\n      await client.query(\"BEGIN\");\n      await client.query(this.SQL_STATEMENTS.DELETE_CHECKPOINT_BLOBS_SQL, [\n        threadId,\n      ]);\n      await client.query(this.SQL_STATEMENTS.DELETE_CHECKPOINTS_SQL, [\n        threadId,\n      ]);\n      await client.query(this.SQL_STATEMENTS.DELETE_CHECKPOINT_WRITES_SQL, [\n        threadId,\n      ]);\n      await client.query(\"COMMIT\");\n    } catch (error) {\n      await client.query(\"ROLLBACK\");\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n}\n"],"mappings":"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"}