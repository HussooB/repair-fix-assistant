{"version":3,"file":"sql.cjs","names":["TASKS"],"sources":["../src/sql.ts"],"sourcesContent":["import { type Checkpoint, TASKS } from \"@langchain/langgraph-checkpoint\";\n\nexport interface SQL_STATEMENTS {\n  SELECT_SQL: string;\n  SELECT_PENDING_SENDS_SQL: string;\n  UPSERT_CHECKPOINT_BLOBS_SQL: string;\n  UPSERT_CHECKPOINTS_SQL: string;\n  UPSERT_CHECKPOINT_WRITES_SQL: string;\n  INSERT_CHECKPOINT_WRITES_SQL: string;\n  DELETE_CHECKPOINTS_SQL: string;\n  DELETE_CHECKPOINT_BLOBS_SQL: string;\n  DELETE_CHECKPOINT_WRITES_SQL: string;\n}\n\nexport type SQL_TYPES = {\n  SELECT_SQL: {\n    channel_values: [Uint8Array, Uint8Array, Uint8Array][];\n    checkpoint: Omit<Checkpoint, \"pending_sends\" | \"channel_values\">;\n    parent_checkpoint_id: string | null;\n    thread_id: string;\n    checkpoint_ns: string;\n    checkpoint_id: string;\n    metadata: Record<string, unknown>;\n    pending_writes: [Uint8Array, Uint8Array, Uint8Array, Uint8Array][];\n  };\n  SELECT_PENDING_SENDS_SQL: {\n    checkpoint_id: string;\n    pending_sends: [Uint8Array, Uint8Array][];\n  };\n  UPSERT_CHECKPOINT_BLOBS_SQL: unknown;\n  UPSERT_CHECKPOINTS_SQL: unknown;\n  UPSERT_CHECKPOINT_WRITES_SQL: unknown;\n  INSERT_CHECKPOINT_WRITES_SQL: unknown;\n  DELETE_CHECKPOINTS_SQL: unknown;\n  DELETE_CHECKPOINT_BLOBS_SQL: unknown;\n  DELETE_CHECKPOINT_WRITES_SQL: unknown;\n};\n\ninterface TABLES {\n  checkpoints: string;\n  checkpoint_blobs: string;\n  checkpoint_writes: string;\n  checkpoint_migrations: string;\n}\n\nexport const getTablesWithSchema = (schema: string): TABLES => {\n  const tables = [\n    \"checkpoints\",\n    \"checkpoint_blobs\",\n    \"checkpoint_migrations\",\n    \"checkpoint_writes\",\n  ];\n  return tables.reduce((acc, table) => {\n    acc[table as keyof TABLES] = `${schema}.${table}`;\n    return acc;\n  }, {} as TABLES);\n};\n\nexport const getSQLStatements = (schema: string): SQL_STATEMENTS => {\n  const SCHEMA_TABLES = getTablesWithSchema(schema);\n  return {\n    SELECT_SQL: `select\n    thread_id,\n    checkpoint,\n    checkpoint_ns,\n    checkpoint_id,\n    parent_checkpoint_id,\n    metadata,\n    (\n      select array_agg(array[bl.channel::bytea, bl.type::bytea, bl.blob])\n      from jsonb_each_text(checkpoint -> 'channel_versions')\n      inner join ${SCHEMA_TABLES.checkpoint_blobs} bl\n        on bl.thread_id = cp.thread_id\n        and bl.checkpoint_ns = cp.checkpoint_ns\n        and bl.channel = jsonb_each_text.key\n        and bl.version = jsonb_each_text.value\n    ) as channel_values,\n    (\n      select\n      array_agg(array[cw.task_id::text::bytea, cw.channel::bytea, cw.type::bytea, cw.blob] order by cw.task_id, cw.idx)\n      from ${SCHEMA_TABLES.checkpoint_writes} cw\n      where cw.thread_id = cp.thread_id\n        and cw.checkpoint_ns = cp.checkpoint_ns\n        and cw.checkpoint_id = cp.checkpoint_id\n    ) as pending_writes\n  from ${SCHEMA_TABLES.checkpoints} cp `, // <-- the trailing space is necessary for combining with WHERE clauses\n\n    SELECT_PENDING_SENDS_SQL: `select\n      checkpoint_id,\n      array_agg(array[cw.type::bytea, cw.blob] order by cw.task_id, cw.idx) as pending_sends\n    from ${SCHEMA_TABLES.checkpoint_writes} cw\n    where cw.thread_id = $1\n      and cw.checkpoint_id = any($2)\n      and cw.channel = '${TASKS}'\n    group by cw.checkpoint_id\n  `,\n\n    UPSERT_CHECKPOINT_BLOBS_SQL: `INSERT INTO ${SCHEMA_TABLES.checkpoint_blobs} (thread_id, checkpoint_ns, channel, version, type, blob)\n  VALUES ($1, $2, $3, $4, $5, $6)\n  ON CONFLICT (thread_id, checkpoint_ns, channel, version) DO NOTHING\n  `,\n\n    UPSERT_CHECKPOINTS_SQL: `INSERT INTO ${SCHEMA_TABLES.checkpoints} (thread_id, checkpoint_ns, checkpoint_id, parent_checkpoint_id, checkpoint, metadata)\n  VALUES ($1, $2, $3, $4, $5, $6)\n  ON CONFLICT (thread_id, checkpoint_ns, checkpoint_id)\n  DO UPDATE SET\n    checkpoint = EXCLUDED.checkpoint,\n    metadata = EXCLUDED.metadata;\n  `,\n\n    UPSERT_CHECKPOINT_WRITES_SQL: `INSERT INTO ${SCHEMA_TABLES.checkpoint_writes} (thread_id, checkpoint_ns, checkpoint_id, task_id, idx, channel, type, blob)\n  VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n  ON CONFLICT (thread_id, checkpoint_ns, checkpoint_id, task_id, idx) DO UPDATE SET\n    channel = EXCLUDED.channel,\n    type = EXCLUDED.type,\n    blob = EXCLUDED.blob;\n  `,\n\n    INSERT_CHECKPOINT_WRITES_SQL: `INSERT INTO ${SCHEMA_TABLES.checkpoint_writes} (thread_id, checkpoint_ns, checkpoint_id, task_id, idx, channel, type, blob)\n  VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n  ON CONFLICT (thread_id, checkpoint_ns, checkpoint_id, task_id, idx) DO NOTHING\n  `,\n\n    DELETE_CHECKPOINTS_SQL: `DELETE FROM ${SCHEMA_TABLES.checkpoints} WHERE thread_id = $1`,\n    DELETE_CHECKPOINT_BLOBS_SQL: `DELETE FROM ${SCHEMA_TABLES.checkpoint_blobs} WHERE thread_id = $1`,\n    DELETE_CHECKPOINT_WRITES_SQL: `DELETE FROM ${SCHEMA_TABLES.checkpoint_writes} WHERE thread_id = $1`,\n  };\n};\n\nexport const tableExistsSQL = (schema: string, table: string) => {\n  const tableWithoutSchema = table.split(\".\")[1];\n  return `SELECT EXISTS (\n  SELECT FROM information_schema.tables \n  WHERE  table_schema = '${schema}'\n  AND    table_name   = '${tableWithoutSchema}'\n  );`;\n};\n"],"mappings":";;;;AA6CA,MAAa,uBAAuB,WAA2B;CAC7D,MAAM,SAAS;EACb;EACA;EACA;EACA;;AAEF,QAAO,OAAO,QAAQ,KAAK,UAAU;AACnC,MAAI,SAAyB,GAAG,OAAO,GAAG;AAC1C,SAAO;IACN;;AAGL,MAAa,oBAAoB,WAAmC;CAClE,MAAM,gBAAgB,oBAAoB;AAC1C,QAAO;EACL,YAAY;;;;;;;;;;mBAUG,cAAc,iBAAiB;;;;;;;;;aASrC,cAAc,kBAAkB;;;;;SAKpC,cAAc,YAAY;EAE/B,0BAA0B;;;WAGnB,cAAc,kBAAkB;;;0BAGjBA,uCAAM;;;EAI5B,6BAA6B,eAAe,cAAc,iBAAiB;;;;EAK3E,wBAAwB,eAAe,cAAc,YAAY;;;;;;;EAQjE,8BAA8B,eAAe,cAAc,kBAAkB;;;;;;;EAQ7E,8BAA8B,eAAe,cAAc,kBAAkB;;;;EAK7E,wBAAwB,eAAe,cAAc,YAAY;EACjE,6BAA6B,eAAe,cAAc,iBAAiB;EAC3E,8BAA8B,eAAe,cAAc,kBAAkB"}